2018/06/13

2018/06/14

#内容
- it研修


# 行動目標
- 一つひとつの意味を理解しつつ聞く（自分は他の人と比較して知識が多かったりするので
- 新しいヒトと話をするヒト
- 梅コースを完了させる（下記の項目）

# Ruby　V 10:12 11:30
○ Command Line
■ Command Line 基礎編 11:30-12:00
○ Ruby on Rails5 13:15-15:00

○ Ruby on Rails5Ⅰ?V
Ruby on Rails5 I 13:15-15:00

○ Ruby on Rails5 Ⅰ,Ⅱ道場コース



# 終わったときの自分の状態
- 細切れだった知識が関連している（コマンドラインなど）
- Rubyと、Python、Javaなど、各言語の得意分野が理解でき、それを使い分けができる。各言語の長所短所がわかる
-
Ruby on Rails 3
	道場 1
Ruby on Rails 4, 5
	道場2



内容
-IT研修
Progateでレッスン

思ったこと
methodや関数といった用語の意味を確認する。正確に使うようにする

<>で囲まれたものは要素と言われる
見出し以外の部分は<p> </p>で囲む
間に表示する文字を挟む場合には<></>と開始タグと終了タグで囲む。
文字がない場合には、<>開始タグだけでオッケー


画像の表示には<img>要素を用います。
<img src="url">のように、src属性のurlの部分に画像のリンクを指定することで、画像が表示されます。
<img>要素はテキストを囲むことがないため、終了タグが要りません。

<li>要素は、囲む要素によって種類が変わるという特徴を持っています。
<ul>要素で囲むと、黒点が先頭につきます。
<ol>要素で囲むと、数字が連番でつきます（ここでは扱いません）。
このように要素を要素で囲むことを入れ子と言います。
囲む方の要素を親要素、囲まれる要素を子要素と呼びます。

CSSとは、HTMLの要素に対して色、大きさ、配置などを指定し、ページをデザインするための言語です。



CSSは、HTMLとは別のファイルに記述します。
HTMLで用意した要素に対して、CSSを用いて「どこの」「何を」「どうする」かを指定することができます。
図の例では、「h1要素の」「color（色）を」「red（赤）」にしています。
（このときの対象(要素名)をセレクタ、変更項目をプロパティと言います）

CSSを書くときも、図のようにインデント（字下げ）をします。
また、CSSのプロパティの末尾にはコロン（:）、行末には セミコロン（;） をつける必要があるので注意しましょう

文字の大きさを指定するにはfont-sizeプロパティを用います。

font-familyプロパティを用いると、フォントの種類を指定することができます。「 font-family: フォント名; 」とすることで、要素にそのフォントを適用できます。フォント名にスペースがある場合は、ダブルクォーテーションで囲みます。


背景色を変えるにはbackground-colorプロパティを用います。 色の指定の方法はcolorプロパティと同様です。
「#dddddd」のように同じ値が続く場合は、「#ddd」と省略できます

要素の横幅、高さを変更したいときには、それぞれwidthプロパティ、heightプロパティを用います。
width, height共にpxで指定していきます。
pxを書き忘れないように注意しましょう。	ー


要素の横幅、高さを変更したいときには、それぞれwidthプロパティ、heightプロパティを用います。
width, height共にpxで指定していきます。
pxを書き忘れないように注意しましょう。


複数の要素に同じclassをつけた場合、それら全てに同じCSSが適用されます。

classにCSSを指定する際に、先頭のドット（.）を忘れてしまうとCSSが適用されません。
classの場合はドットが必要で、タグの場合は必要ない、ということをしっかりと覚えておきましょう。
<li class = ""> ダブルクオテーション内に暮らすめいを記述する


<head>要素にはページに関する情報、<body>要素には実際に表示したい内容を書きます。

<!DOCTYPE html>の部分はDOCTYPE宣言と呼ばれるもので、HTMLのバージョンを宣言するためのものです。
今回は最新バージョンのHTML5を使うため、<!DOCTYPE html>を使用します。


<head>要素にはWebページの設定に関する情報を書いていきます。
<head>要素内に記述した内容はWebページには表示されません。
<head>要素には必ず入れる3つの要素がありますが、それらについては次のレッスンで学びます。

<head>要素の中では、以下のように①文字コードの指定、②ページのタイトルの設定、③CSSの読み込みなどを行っていきます。
これらは定型文のようなものなので完全に覚える必要はありませんが、どのようなものがあるのかを知っておきましょう。

文字コード指定<meta charset = "UTF-8">
<title>aaa</title> プラブ座のタブに表示される
CSSを読み込むためには、<link rel="stylesheet">を利用
読み込むファイルの指定には、link rel = "sytlesheet" href="sytlesheet.css">のようにhref属性で読み込むcSSファイルを指定する

レイアウトは<div>要素によって構成していきます。
<div>要素の「div」は「division」の略で、要素をグループ化するために使用されます。
下の図の例では、「header」、「main」、「footer」というclass名を持った3つの<div>要素でレイアウトを分割しています。

ウェブページのレイアウトは<div>要素によって構成する
ヘッダ、フッター、っメインと各要素を指定していく

<div class="header"></div>

styleshieetにｈてlist-sytle:none;で指定すると、リスト先頭の黒丸を消すことができる

cssにて"float"プロパティを用いると、師弟したヨウ素を横並びにする
float:left;と師弟すると、ヨウ素が比田井→から準に横に並ぶ


余白の調整
padding: 値;
上下左右すべてのお方向にその大きさの余白が追加されます

「padding-top: 値;」などとすると、その方向のみに余白が追加されます。
他にpadding-bottom、padding-left、padding-right

指定したい値が方向ごとに異なる場合、個別で指定する方法もありますが、まとめて書くことも可能です。
値を4つ、スペース区切りで指定した場合、「上」「右」「下」「左」の順で適用されます。
値を2つ指定した場合、「上下」「左右」の順に適用されます。

「.header-list」の後にスペースを空けてliと続けると、「header-list」の中の<li>要素にのみCSSを適用することができます。
これにより、ヘッダーの<li>要素とフッターの<li>要素に別々のCSSを適用することができます。

続けて、メイン部分のレイアウトを作っていきましょう。
main要素は、「copy-container」、「contents」、「contact-form」の3つの要素で構成されています。

文中の一部にCSSを適用させたい場合は、<span>要素で囲みます。
下の図では、<span>タグにCSSを指定することで、文字の色を一部変えています。
<span>要素の前後には改行は入りません。前後に改行が入るタグと入らないタグに関して、次のスライドで一旦整理してみましょう


前後で改行が入り、親要素の幅一杯に広がる要素をブロック要素といいます。これまで勉強してきた<div>要素や<h1>要素、<p>要素はブロック要素です。

<span>要素や<a>要素のように改行されない要素をインライン要素といいます。


<div>や<span>は区切りでしかない。だいたいそれらには<div class="----">とclassがついている
なので、divやspanでくぎってそれぞれにclassで命名して区別するイメージ

<img src="URL"> 挟み込むtextはないので、終了タグはなく終了する


<div>
開始タグと終了タグで囲まれているものの間は開業して大丈夫
</>


要素にボーダー（枠線）をつけるには、borderプロパティを用います。図のように、枠線の太さ、種類、色を指定して使用します。

枠線の太さ、種類、色を指定して使用します。

上下左右すべてに線を付けたい場合はborderとし、特定の場所にのみ付けたい場合は「border-bottom」のように、「border-方向」とします。
他にborder-top、border-left、border-rightなどがあります。

paddingはborderの内側の余白を作ります。
borderの外側に余白を作りたい場合、marginを用います。
値の指定の方法は、paddingと同じです。


これまで勉強してきたborder, padding, marginは、ボックスモデルという概念に基いています。
HTMLの全ての要素には、border（初期状態では表示されない）があり、その外側の余白はmargin, 内側の余白はpaddingです。


文字入力欄

それでは入力欄の作り方を見ていきましょう。
<input>要素は１行のテキスト入力を受け取るための要素です。
<textarea>要素は複数行のテキスト入力を受け取るための要素です
<input>要素は終了タグが不要な点に注意してください。



<div class="header">と<div class="footer">のような、ヘッダーとフッターのためのタグは非常によく使われるので、HTMLには<header>と<footer>というタグが用意されています。
<header>, <footer>を使う方が一般的なので、こちらを使いましょう。

トップ部分の背景には画像を表示します。
CSSで背景画像を指定するにはbackground-imageプロパティを用います。
background-image: url(画像のURL);のように使います。

background-imageで指定された背景画像は図のように表示範囲を埋め尽くすまで、繰り返し表示される性質があります。
background-size: cover;を指定すると、1枚の画像で表示範囲を埋め尽くすように画像の大きさが拡大縮小します。

中央に寄せるためにはmarginの左右にautoを指定します。
marginにautoを指定するときは、必ずwidthを併せて指定します。
なお、上下のmarginにautoを指定することはできません。
このようなcontainerクラスを作る意味は今は理解しなくて大丈夫です。
後に便利になるので、作っておきましょう。

opacityプロパティを使えば要素を透明にできます。
透明度は0.0(完全に透明) ~ 1.0(完全に不透明)の数値で指

letter-spacingプロパティを用いることで文字の間隔を指定することができます。

インラインヨウ素（<a>たぐなど）
はwidth heightが師弟できず、上下のマージンも指定できない
ボタンを作っていきます。ボタンは<a>タグで指定します。
しかし<a>タグはインライン要素であり、インライン要素にはwidthやheightが指定できないなど不便な点があります

インラインブロックヨウ素
居ブロック要素とインラインヨウ素の特区張を併せ持つインラインブロックヨウ素がある

<a>タグは初期状態でインラインヨウ素になっているが、displayプロパティを使うと、インラインブロックヨウ素に変更できうｒ
displayプロパティは


displayプロパティはblock（ブロック要素）, inline-block（インラインブロック要素）, inline（インライン要素）を指定することができます。

ボタンのように、「共通の部分があるが、それぞれ小さい変化をつけたいとき」にはクラスの名前を複数指定すると便利です。
下図のように、半角スペースで区切って複数のクラスを指定することができます。

カーソルが乗ったときの状態をhoverと言います。
CSSで、セレクタ:hoverとすることで、カーソルが乗ったときのCSSを指定することができます。

￥
text-alignプロパティを用いることで、テキスト等のインライン要素やインラインブロック要素の配置を指定することができます。
leftで左寄せ、centerで中央揃え、rightで右寄せに設定することができます。

要素を中央寄せにする方法として、margin: 0 autoとtext-align: centerを学びましたが、それらの違いを整理しましょう。
containerクラスのように、広い範囲を囲うようなブロック要素の場合はmarginを、テキストやボタンのようなインライン要素・インラインブロック要素の場合はtext-alignを使うようにしましょう。

これまで要素を透明にするにはopacityを用いてきました。
しかし、opacityには要素の中身全てを透明にするという性質があります。背景色のみを透明にするには、rgbaというものを使う必要があります。
それを学んでいきましょう。

rgbaを学ぶには、まずrgbというものを理解する必要があります。
transitionを使うとアニメーションをつけることができます。
「変化の対象」や、「変化にかかる時間」などを指定できます。
「変化の対象」にはcolorなどのプロパティを指定しますが、allを指定すると全てのプロパティに適用出来ます。
transitionは多くの場合hoverと組み合わせて使います。rgbは色の指定の仕方の1つで、3つの値の組み合わせで表示する色を決めます。色を指定するときは今まで使用してきた#ffffffのような記法を使ってもrgbを使っても構いません。


line-heightプロパティを使うと、行の高さを指定することができます。
値が大きいほど行間が大きくなります


line-heightプロパティを使うと、行の高さを指定することができます。
値が大きいほど行間が大きくなります

<a>タグはインライン要素なので、中身のテキストの部分しか大きさを持ちません。その結果、<a>タグをクリックできる範囲はテキストの部分だけになってしまいます。
<a>タグをブロック要素にすると、大きさが親要素いっぱいに広がるので、全体をクリックできるようになります。

font-weightプロパティを用いると文字の太さを変更することができます。normalまたはboldを指定します。
<h1>~<h6>の要素は初期状態でfont-weight: bold;となっているので、font-weight: normal;と指定すれば文字が細くなります。


ボックスのwidthやheightをpxではなく%で指定すると、親要素に対してどのくらいの幅や高さを持つか指定することができます。

レッスン紹介部分を作っていきましょう。
通常、HTMLでは要素同士が重なって表示されることはありません。
しかし、CSSを用いることで要素同士を重ねることができます。
今回は画像アイコンと文字が重なるようにする方法を学びます。

HTMLの要素同士は通常重なって表示されることはありませんが、position: absolute;を使うと、要素同士を重ねて表示することが出来ます。
サイト全体の左上部分を基準とし、そこからの位置をtopとleftを用いて指定します。また、rightやbottomを併用することも可能です。

position: absolute;の基準位置はサイト全体の左上部分ですが、この基準位置は変更することが出来ます。
基準としたい親要素にposition: relative;と指定すると、その要素の左上部分が基準位置となります。

ボックスに影を付けるためにはbox-shadowプロパティを用います。
以下の図のように「影の位置」と「影の色」を指定します。

cursorプロパティを用いることでマウスのカーソルが要素に乗ったときのカーソルの形を変えることができます。
タグによってcursorが初期状態で設定されているものもあり、例えば<a>タグは初期状態でpointerが設定されています。


セレクタにactiveを用いることで、要素がクリックされている間だけCSSを適用することができます。
セレクタ:activeというように指定します。

box-shadow: none;とすると、影を消すことが出来ます。
このように多くのプロパティはnoneを指定することによって消すことができます。

要素の位置を変更する方法を学びましょう。
前回position: relative;はposition: absolute;の基準位置を決めるために使っていましたが、要素の位置を変更するためにも使うことが出来ます。
position: relative;をtopやleftと併用すると、その要素を本来の位置からずらせます。



クリック時に、以下の処理をすることによって、ボタンがへこんで見えるようになります。
・box-shadowをnoneにする
・position: relative;とtopによって影の分だけ位置を下げる


CSSで個タグを指定するときは、hooter a{ }のようにへいれつすればオッケー


position: fixed;を使うと、常に要素を画面上の指定した位置に固定させておくことができます。
位置は、top、left、right、bottomを使って指定します。


z-indexプロパティは、要素の重なりの順序を指定する際に使用します。
z-indexは整数値で指定し、値が大きいほど上に表示されます。
z-indexプロパティは必ずpositionプロパティと併用する必要があるので、注意しましょう。



RRbuy

下図のように文字列の中で、#{変数名}とすることで、変数を代入している値に置き換えて、文字列に含めることができます。
これを「変数展開」と呼びます。

変数展開をする際は注意点があります。
実はダブルクォーテーションを使った文字列の場合しか変数展開はされません。シングルクォーテーションの場合は、変数展開が行われず、そのまま文字列として出力されてしまうので注意しましょう。

数値と文字列を足し算で連結することはできません。
しかし右の図のように変数展開を用いると、数値の入った変数も問題なく文字列に含めることが可能です。
変数を文字列に含める場合は、基本的に変数展開を使うようにしましょう。

if文を用いると「もし○○ならば●●を行う」という条件分岐が可能になります。ifの後ろに条件式を書き、それが「成り立つ」場合、処理を実行します。また、処理はifとendで囲みます。

先ほどの例で出力された「true」は真偽値と呼ばれるものです。
真偽値にはtrueとfalseという2つの値しか存在しません。
条件式は、成り立つと「true」、成り立たなければ「false」という真偽値に置き換わります。よって下図のように条件式をputsしてみると、trueやfalseが出力されています。

rubyはインデント関係ない。ただ見やすくするだけのもの。Pythonとは異なる


複数の値をまとめて管理するには、配列というものを用います。
配列は、[値1, 値2, 値3]のように作ります。配列に入っているそれぞれの値のことを要素と呼びます。
配列を使うと、複数の文字列や数値をまとめて書くことができます。



変数の場合と同様に、配列の要素の値も変数展開を用いて文字列の中に含めることができます。

繰り返し処理
繰り返し処理には、each文というものを使います。
each文を使うと、配列の要素を順番に取り出して処理を行うことができます。
each文は、図のように、「配列.each do |変数名|」と書き、「end」までの間に実行したい処理を書きます。

nammes.each do |name|
	puts name
end

each文は配列の要素の数だけ繰り返し処理を行います。
図のように、「|」で囲まれた変数に配列の要素が1つずつ入っていき、その上でeach文の中の処理が実行されていきます。
each文内の変数名（name）は好きな名前をつけられますが、配列の変数名（names）の単数形にすることが慣習上多いです。

複数の値をまとめて管理する方法としては、配列の他にもハッシュというものがあります。
配列は複数の値を並べて管理するのに対して、ハッシュはそれぞれの値にキーと呼ばれる名前をつけて管理します。
次のスライドからハッシュの書き方を学んでいきましょう。

ハッシュは以下の図のように、キーの部分を文字列ではなく、先頭にコロン「:」を付けた書き方をすることもできます。
この「:name」という書き方のことをシンボルと言います。

vハッシュのキーにシンボルを用いるときには、省略した書き方をすることができます。具体的には「:key =>」を「key:」というように省略することができます。


ハッシュの書き方
# キーが文字列の書き方
{"name" => "Suzuki"m "age" =>19}
# キーがシンボルの書き方
{:name => "Suzuki", :age =>21}
# キーがシンボルの書き方（省略形）
{name:"Suzuki", age:21}
キーがシンボル省略形の場合には、キーと":"の間にはスペースを空けない


nilとは何者やねん nul と同様のものらしい

true :[flaseと nil]以外
false: flaseとnil

ここからは、要素がハッシュになっている配列を見ていきましょう。
配列の要素には、文字列や数値だけでなく、ハッシュも使うことができるので、左の図のような配列を作ることができます。
その際、コードが横に長くなることを防ぐために、右の図のように要素ごとに改行することがよくありますので、覚えておきましょう。

先ほどのハッシュの要素の値の扱い方は、さらに省略することができます。
具体的には、配列[インデックス番号][キー]で、特定のハッシュの値を用いることができます。
見慣れない書き方で難しく感じるかもしれませんが、配列[インデックス番号]がハッシュに置き換わる、というように考えると理解しやすくなります。



def ===

end

→def と endのセットで理解



ここからは、メソッドの処理結果を呼び出し元で受け取る方法を学びます。
呼び出し元で受け取る処理結果を戻り値（もどりち）と呼び、このことを「メソッドが戻り値を返す」と言います。
下のイメージ図では、addメソッドが「3」と「7」を受け取り、処理結果の「10」を呼び出し元に返しています。この「10」にあたるのが戻り値です。

メソッドの中でreturnを使うと、呼び出し元で値を受け取れるようになります。
「return 値」と書くことで、メソッドはその値を戻り値として返します。


戻り値がある場合、メソッドの呼び出し部分がそのまま戻り値に置き換わります。
よって、図のようにメソッドの呼び出し部分を変数に代入するように書くことで、メソッドの戻り値を受け取ることができます。

戻り値も引数と同様に、様々な値を用いることができます。
また、if文で使うような条件式をreturnすると、その条件式の結果として得られる真偽値（trueまたはfalse）を返すことができます。
真偽値を返すメソッドは、メソッド名の末尾に「?」をつける慣習があるので、覚えておきましょう。

returnについて詳しく見ていきましょう。
returnは、戻り値を返すだけでなく、メソッドの処理を終了させる性質も持っています。
よって、returnの後にあるメソッドの処理は実行されませんので注意しましょう。

メソッド内で条件式ifをもちいることもできる
その場合には if 内であってもreturnが実行されれば、ソレ以降の処理は停止する
下記の場合には、priceが100以上であれば、priceが返る。また、priceが100より小さい場合には、if内はfalseで実行されず、その↓のreturn price + 10が実行される

def ship(price)
		 if sum >= 100
		 	return price
		 end
	return price + 10
end


最後に、キーワード引数という特殊な書き方について見てみましょう。
引数の数が多くなると、呼び出し側で値がどの引数に入るのかがわかりにくくなります。
キーワード引数を用いた書き方をすることで、右の図のように呼び出し側で引数を明記することができます。

class
classは設計図
class クラス名

end

classとendはセットで始まる
情報を持たせるためには、「attr_accessor シンボル」のようにします。以下の図のようにすることで、Menuクラスのインスタンスにnameという情報を持たせることができます。
また、この「name」という情報のことをインスタンス変数と呼びますので覚えておきましょう。
シンボル :名前

1つのクラスに対して、インスタンス変数は複数用意することも可能です。
今回は以下の図のように、Menuクラスに「name」と「price」の2つのインスタンス変数を用意してみましょう。

クラス（設計図）を元に、新しくインスタンスを生成するには、「クラス名.new」とします。
また、「変数名 = クラス名.new」とすることで、生成したインスタンスを変数に代入することができます。


インスタンスに情報をもたせるには、クラスで用意したインスタンス変数に値を代入する必要があります。
具体的には「インスタンス.変数名 = 値」とすることで、そのインスタンス変数に値をセットすることができます。


クラスのなかではメソッドを定義できる

クラスの中で定義したメソッドは、インスタンスに対して使うようにして呼び出します。
具体的には、「インスタンス.メソッド名」のようにすることで、そのメソッドを呼び出すことができます。
このようにクラスの中で定義し、インスタンスに対して呼び出すメソッドのことをインスタンスメソッドとよぶ
したがって、インスタンスメソッドも、引数を受け取ったり戻り値を返すことができます。




# [puts]と[return]の違い

def sum(a,b)
  puts 10
  return 20
end

x = sum(100,200)
puts x

# どの言語でもメソッドの定義は読み込まない、一旦飛ばす。
それ以降に、メソッドが利用された場合には立ち返って、メソッドを参照する。


self

インスタンスメソッドの中では、特殊な変数「self」を用いて「self.変数名」とすることで、インスタンス変数を扱うことができるようになります。
インスタンスメソッドでは、変数「self」に、呼び出したインスタンス自身が代入されています。

ここで一度、クラスとインスタンスについておさらいしましょう。
クラスは設計図のようなもので、その設計図からつくる実際の「もの」にあたるものがインスタンスです。
インスタンスが持つ情報である「インスタンス変数」と、インスタンスに対して呼び出す「インスタンスメソッド」は、クラスの中で定義します。

まずは、インスタンスを生成した直後に処理を実行することができる、initializeメソッドというものを学びましょう。
initializeメソッドは、「クラス名.new」でインスタンスを生成した直後に自動で呼び出されます。
実際の使い方については、次のスライドで見てみましょう。

initializeメソッドは、他のインスタンスメソッドと同じように定義することができます。
以下の例では、「Menu.new」でMenuインスタンスが生成された直後に、initializeメソッドが呼び出され、その中の処理が実行されます。

initializeメソッドは通常のインスタンスメソッドと同じように、引数を渡すこともできます。
その際、「クラス.new」に対して引数を渡すことで、initializeメソッドにその値を渡すことができます。


# Pythonの場合のselfの意味

- 下の例を見ると、"self."は、"class Example"内全体でつかえるという意味
- また、クラス内で定義するメソッドでは定義する段階で引数()内に"self"は必須
- →実行するさいにはselfは必要ない（下から1,2行目)
- クラスのメソッド内だけで有効な変数には"self"はつけない→下の例の " tot "


class Example():

    def __init__(self, a,b,c):
        self.num1 = a
        self.num2 = b
        self.num3 = c

    def print_tot(self):
        tot = self.num1+self.num2+self.num3
        print(tot)

myinstance = Example(1,2,3)
myinstance.print_tot()


目標物では、メニュー名の左に0から順番に番号がついていました。
番号をつけるには、番号を保存するための変数（図の例では変数index）をeach文の外で用意して、each文の処理の中で値を1だけ増やして更新するようにします。


入力を受け付けるには「gets.chomp」を使います。このコードが実行されると、コンソールが入力待機状態になります。
「変数 = gets.chomp」とすることで、エンターキーを押されるまでに入力された値を変数に代入することができます。

「gets.chomp」で入力された値を受け取ることができましたが、実はこれは文字列になるため、「3」と入力しても文字列の"3"になってしまいます。
数値の計算などに用いる場合は、これを数値に変換する必要があります。
そのためには、「gets.chomp.to_i」とすることで、入力された内容を数値に変換し、計算などにも使えるようになります。


すでにあるMenuクラスを利用して、それをもとにFoodクラスとDrinkクラスをつくることができます。
そうすることで、共通部分をまとめることができ、効率的にコードを書くことができます。

あるクラスを元にして新たなクラスをつくることを「継承」と呼びます。
「class 新しいクラス名 < 元となるクラス名」とすることで他のクラスを継承して、新しいクラスを定義することができます。
このとき、新しいクラスは「子クラス」、元となるクラスは「親クラス」と呼ばれます。

子クラスにインスタンス変数を追加するためには、これまで通り「attr_accessor」を用います。

親クラスにあるメソッドと同じ名前のメソッドを子クラスで定義すると、メソッドを上書きすることができます。これをメソッドの「オーバーライド」と呼びます。
オーバーライドをすると、子クラスのインスタンスは、親クラスのメソッドではなく、子クラスで定義したメソッドを呼び出すようになります

オーバーライドについてもう少し見てみましょう。
図のように、子クラスのインスタンスは、子クラスで定義したメソッドを優先して呼び出すようになっています。したがって、子クラスと親クラスに同名のメソッドがある場合は、子クラスのメソッドを呼び出すので、結果的にメソッドの内容が上書きされたようになります。


メソッド内の重複

オーバーライドしたメソッドの中で「super」とすることで、親クラスの同名のメソッドを呼び出すことができます。
あくまでメソッドを呼び出しているので、親クラスのメソッドの定義に合わせて、superに対して引数を渡す必要があります。


メソッドsuper

親クラスの変すんを引用するための関数
super(name: name, price; price)のように使用する
superのあとの()の間にはスペースは要らない


日付を扱うためには、Dateクラスというものを用います。
DateクラスとはRubyがすでに用意しているクラスで、図のようにrequireを用いて読み込むことで、自分でクラスを定義しなくても使うことができます。
このようにすでに用意されているクラスは、requireの書き方が少し異なるので注意しましょう。


require "date"

puts birthday.sunday?


クラスメソッドは、「def クラス名.メソッド名」とすることで定義できます。インスタンスメソッドとの違いはメソッド名の前にクラス名を書く必要がある点です。
今回はMenuクラスに、「is_discount_day?」というクラスメソッドを定義してみましょう。


インスタンスメソッドの中でクラスメソッドを呼び出す
クラスメソッドはクラスの中でも、同じように呼び出すことができます。
今回は、Menuクラスのインスタンスメソッドである「get_total_price」メソッドの中で、クラスメソッド「is_discount_day?」を呼び出してみましょう！


インスタンスメソッド
インスタンスメソッドは、インスタンスに対して呼び出す
class Menu
	def info

	end
end

menu1 = Menu.new
menu1.info


クラスメソッドはクラスに対して呼び出す
class Menu
	def Menu.is_discount_day?
	end
end

Menu.is_discount_day?


ckassメソッドとインスタンスメソッドの違い
classだとほかのクラスで必要になったときにも呼び出せる
インスタンスだと、

インスタンスは具現化したもの
クラスはその元

クラスメソッドであれば、例えば「家電の割引」に利用するときにも呼び出せる
そのクラスメソッドだけ

インスタンスメソッドはそのインスタンス固有のメソッド



# コマンドライン

touch ファイル作成
cat ファイルの中身を確認する
mkdir Directoryを作成する
cd ディレクトリの移動、ファイルのお指定はできない
ルートディレクトリ　一番親のディレクトリ
pwd カレントディレクトリを確認する (print working directory)
ls カレントディレクトリの中身を確認する

cdコマンドでは、ディレクトリを指定せずに「cd」のみで実行すると、ホームディレクトリと呼ばれるディレクトリに移動することができます。
ホームディレクトリは、下の図のように「~」で表されます。

ホームディレクトリは、ユーザーが作業をするときに起点にするディレクトリのことを言います。ユーザーが起点とするディレクトリのため、簡単に移動できるようになっています。このレッスンのホームディレクトリはprogateディレクトリに設定されています。

mv ファイルの移動 mv ファイル名 ディレクトリ名
	mv 移動したいディレクトリ 移動先のディレクトリ (ディレクトリ以下のファイルやディレクトリも一緒に移動する）

ファイルメイの変更
mv 現在のファイル名 新しいファイル名
mv 現在のディレクトリ名 新しいディレクトリ名


cp コピーするファイル名　新しいファイルﾒｲ
Fileをコピーするコマンド

cp -r とするこどでディレクトリもコピーできる

cp -r コピーするディレクトリ名名 新しいディレクトリ名

rm ファイルの削除
rm 削除するファイルメイ

rm -r とするとディレクトリを削除できる


# Ruby on Rails
ウェブアプリケーション作成のためのフレームワーク
フレームワークを使うと、開発に必要な作業を減らすことができるから、多くの開発者がフレームワークを利用している

Railsで開発を始めるには、左図の「rails new アプリケーション名」という
コマンドをターミナルで実行します。
このコマンドを実行することで、入力したアプリケーション名と同名のフォルダが作成され、その中に開発に必要なフォルダやファイルが用意されます。

サーバーの立ち上げ
rails server
トップページを作成するには、「rails generate controller home top」
というコマンドをターミナルで実行します。
このコマンドを実行すると、新しいWebページが自動で作られ、
「localhost:3000/home/top」というURLにアクセスできるようになります。

# rails でページを表示するには、右の3つのファイルが必要。

-ビューview
-コントローラ（controller)
-ルーティング(routing)



ビューとは、ページの「見た目」を作るためのHTMLファイルです。
ブラウザとRailsのやりとりの中で、Railsからビューが返され、ページが表示されます。
ビューはviewsフォルダの中に置かれます。
先ほどの「rails generate controller home top」を実行すると、
viewsフォルダの中に「homeフォルダ」と「top.html.erb」という
ファイルが作成されます。「erb」は少し特殊なファイル形式ですが、
今はただのHTMLファイルだと思っておいてください。

コントローラ
ページを表示するとき、Railsの中ではコントローラを経由してビューをブラウザに返しています。ページを表示するとき、Railsの中ではコントローラを経由してビューをブラウザに返しています。

コントローラファイルの中身を見てみましょう。
「rails generate controller home top」を実行したとき、
「home_controller.rb」というコントローラのファイルが作成され、ファイルの中に「topメソッド」が追加されます。
コントローラ内のメソッドを「アクション」と呼びます。

コントローラ内のアクションは、ブラウザに返すビューをviewsフォルダの中から見つけ出す役割を担っています。具体的には、アクションは、コントローラと同じ名前のビューフォルダから、アクションと同じ名前のHTMLファイルを探してブラウザに返します

ルーティングは、送信されたURLに対して「どのコントローラの、どのアクション」で処理するかを決める「対応表」のことです。
ブラウザでURLを入力すると、ルーティングがURLを見て、適切なコントローラのアクションを呼び出します。

1.ブラウザ（表示前）URL(home/top)に対応するHTMLファイルをリクエスト
2.（ルーティング（対応表）を参照し、）コントローラ(ex. home)のアクション(ex. top)を呼び出す→次にコントローラにいき
3.コントローラがURLに対応したHTMLファイルを送信する（例ではtop.html.erb)
URL 	| コントローラ 	|アクション |
homt/top|	home		|top		|

。

ルーティングは「config/routes.rb」に定義され、右図のように
「get "URL" => "コントローラー名#アクション名"」という文法で
書かれます。
これによって、ブラウザから「localhost:3000/home/top」というURLが
送信されたときに、homeコントローラーのtopアクションで処理されるようになります。
ルーティングに記述されていないURLにはアクセスできない


ルーティングを書き換えることで、トップページのURLを変更することが
できます。右図のように書き換えると、「localhost:3000/top」というURLで
トップページにアクセスできるようになります。
URLを変更しても、"home#top" の部分が変わらない限りhomeコントローラのtopアクションに対応するビューファイル（= top.html.erb）の内容がブラウザに表示されます。


トプページ以外のページはコマンドを用いて自銅滴に作れるわけではない。
トップページを作るときに入力したコマンドには、実は「コントローラ名」と「アクション名」が含まれています。
「rails generate controller コントローラ名 アクション名」を実行することで、コントローラと、それに対応したファイルが自動で用意されます。
しかし、同じ名前のコントローラがすでにある場合は、このコマンドを使うことはできません。


新しいページを追加するには、コマンドで自動生成されていた、ルーティング、コントローラ (アクション)、ビューを自分で用意する必要がるあるのじゃ。


#見た目を整えるCSSファイルの作成

CSSファイルは「app/assets/stylesheets」フォルダに入っています。
「rails generate controller home ...」コマンドを実行したときに、
CSSファイル(home.scss)も自動生成されます。
「scss」はCSSを拡張したもので、CSSを効率的に書く文法も使用できますが、このレッスンではCSSの文法のみを用いていきます。

画像は、「public」フォルダに配置しておくと、「<img src="/画像名" >」や「background-image: url("/画像名");」のように、画像名を指定するだけで、簡単に画像を表示することができます。
→必ず"/"をつける



「localhost:3000」 (後ろに/○○がないURL) に対応するルーティングは、
「get "/" => "コントローラ名#アクション名"」というように、URLに"/"を
指定します。

リンクを作成するためには、<a>タグでテキストを囲み、「href=" "」の中にURLを指定する必要があったことを思い出しましょう。
hrefの中身をルーティングのURL部分と同じにすることで、簡単にリンク先を指定することができます。

hrefの中身は  " / "で開始する

データベースと表示物

埋め込むRubyコードをブラウザに表示したい場合には、以下の図のように
<% %>ではなく、<%= %>を用います。

埋め込むRubyコードをブラウザに表示したい場合には、以下の図のように
<% %>ではなく、<%= %>を用います。

投稿が増えたときのために"each分" で囲む

アクションで定義する
 Rails ではビューではなく、アクションで定義することが一般的なのじゃ。
ここからはコントローラのアクション内で変数を定義してみよう。


定義する
変数
ビューで使う変数はアクション内で定義するようにしましょう。
以下の図のように、「def index」と「end」の間で変数を定義することで、その変数をindex.html.erb内で使用することができます。
変数の前に付いている「@」の意味は次のスライドで説明します

通常、アクションで定義した変数をビューで使用することはできません。
しかし、変数名を「@」から始めることでこの変数は特殊な変数となり、ビューファイルでも使用することができます。
ですので、アクションで定義したビュー用の変数には「@」をつけ忘れないようにしましょう。


データベースは下の図のような表でデータを管理しています。その表のことを「テーブル」と呼びます。下の図は投稿データを扱うための「postsテーブル」で、横の行が１つ１つの投稿データになっています。
また、縦の列のことを「カラム」、1行ずつのデータのことを「レコード」と呼びます。

データベール
テーブル（データベースの龍録されている表全体のこと）
カラム（列）レコード（行）で構成されている

posteテーブルを作成刷る手順
1.step1 えーたベースに変更を指示するファイルを作成する
2.データベースに変更を反映する


マイグレーションファイルと呼ばれる、データベースに変更を指示するためのファイルを作成しましょう。右の図のようなpostsテーブルを作成するマイグレーションファイルは
「rails g model Post content:text」というコマンドで作成することができます。
g: generate でも可能
posts: モデル名 テーブルを作成する場合には、Postと単数形にする
content: カラム名
text: データ型

また、「text」は「長い文字列」を意味しており、contentカラムにどのようなデータが入るかを意味しています。


データベースに変更を反映するには「rails db:migrate」を実行すればそれでよい


Railsでは、データベースに反映されていないマイグレーションファイルが存在する状態で、どこかのページにアクセスすると以下のようなマイグレーションエラーが発生してしまいます。そのため、マイグレーションファイルを作成した場合は必ず「rails db:migrate」を実行する必要があります。

テーブルを竿うさするためのモデルとよろしくお願いします。バラル特殊なクラスを用いてデータベースは扱う
クラスはいわゆると同じ
rails g modelコマンドで postsテーブルを操作するためのPostモデルがすでに生成されている。

Railsでは、データベースに反映されていないマイグレーションファイルが存在する状態で、どこかのページにアクセスすると以下のようなマイグレーションエラーが発生してしまいます。そのため、マイグレーションファイルを作成した場合は必ず
「rails db:migrate」を実行する必要があります。

Application recored を継承したクラスを「model」という

rails g model Post  の"Post"の部分はモデル名を指定する

ここで改めて「rails g model」コマンドについて見てみましょう。
「rails g model Post ...」の「Post」の部分には、実はモデル名を指定します。
そして、このコマンドによって、以下の2つのファイルが作成されます。
・app/modelsフォルダにモデルが定義されたファイル
・db/migrateフォルダにマイグレーションファイル

ターミナル上で「rails console」と入力し実行（Enter）することで、コンソールを起動することができます。コンソールを起動した状態で、「1+1」を実行すると、その実行結果が表示されます。
また、「quit」を実行すると、コンソールを終了することができます。

コンソールでは下の図のように、変数を定義することもできます。
定義した変数は「quit」でコンソールを終了するまで使い続けることができます。

postsテーブルにdataを追加するには
1/newメソッドでpostモデルのinstanceを作成
2.postsテーブルに保存

以上2つの手順を行う。

「rails console」を使って、Postモデル（Postクラス）からPostインスタンスを作成しましょう。インスタンスを作成するにはnewメソッドを使います。
下の図のように書くことで、contentが「Hello world」であるPostインスタンスを作成することができます。

「rails console」を使って、Postモデル（Postクラス）からPostインスタンスを作成しましょう。インスタンスを作成するにはnewメソッドを使います。
下の図のように書くことで、contentが「Hello world」であるPostインスタンスを作成することができます。

rai
トップページを作るときに入力したコマンドには、実は「コントローラ名」と「アクション名」が含まれています。
「rails generate controller コントローラ名 アクション名」を実行することで、コントローラと、それに対応したファイルが自動で用意されます。
しかし、同じ名前のコントローラがすでにある場合は、このコマンドを使うことはできません。
(ex, rails generate controller home about)

homeコントローラーではなく、投稿に関することは投稿に冠するコントローラーを作成したほうがよい
→ rails generate controller posts（コントローラー名） index(アクション名）




テーブルからdataを取り出す



post = Post.first
post.content
とすることで、Post.firstで取得したdataから投稿内容を取得することができる


テーブルからすべてのデータを取り出す方法
Post.all
テーブルにある全てのデータが配列でsy得できる
データは配列であるから、Post.all[0]として取得するデータを指定できる
Post.all[0]
Post.all[0].contentとすれば投稿内容を取得できる

コンソールを用いたデータの操作
データの作成(new, save)
データの取得(Post.all, post.oontent...)

モデルはデータベースとのやりとりをする言葉
お↓ルを

コントローラーは支持を書くのみ
Postは


共通のレイアウト

Railsでは、「views/layouts/application.html.erb」に共通のHTMLを書いておくことができます。
初期状態でも、<head>タグや<body>タグなどの共通部分はこちらに書かれています。今回は、以下の図のように、ここにヘッダーを追加し、どのページでも共通のヘッダーが表示されるようにしましょう。

「views/layouts/application.html.erb」には<%= yield %>というコードがあります。top.html.erbなどの各ビューファイルは、この<%= yield %>の部分に代入され、application.html.erbの一部としてブラウザに表示されていました。この仕組みによって、ヘッダーなどの共通のレイアウトを1つにまとめることができます。


では、最後に投稿一覧ページへのリンクを追加しよう。Rails ではlink_toというメソッドを使うと<a>タグを作成することができるぞ。 link_to メソッドは Ruby のコードなので、「<%=%>」で囲むことに注意するのじゃ。

第一引数に表示する文字を、第二引数に URLを書くことでリンクが作成されるぞ。


投稿とその詳細表示

idカラム
データベースに保存されるさいに、自動的に数字が入る。
idは1から順に入っていき、データごとにちょうふくしないようになっている

created_atカラムとupdated_atカラムには、データベースに保存された時刻が自動で入るようになっています。
updated_atはデータ更新時にも時刻が更新されます。
（「データの更新」は後のレッスンで扱っていくので、ここでは理解しなくて大丈夫です。）

投稿詳細ページにて、データベースから徳亭のidを表示する方法
find_byメソッド

特定のidの投稿を取得するためには、find_byメソッドを用います。
find_byメソッドは、ある条件に合致するデータを取得することができます。
図のように、「モデル名.find_by(カラム名: 値)」とすることで、その値を持ったデータをデータベースから取得することができます。
ex. post = Post.find_by(id: 3)

idが3の投稿を取得する。
m


投稿詳細ページを作成する

新たにページを作成するとき
必要な要素
- ルーティング
- アクション
- ビュー

投稿詳細ページのURLに標示したいという後のidを入れるようにする
idをもつ投稿データを表示するようにする

ex. URLが/posts/1やposts/2のときにshowアクションに行くようにする
→get "posts/1" => "posts#show"

ただし上記の書き方であるとidの分だけposts#showアクションをつくらないと行けない
そのまとめて投稿するために、

ルーティングのURL部分に「:」を用いて「posts/:id」と指定することで、「/posts/1」でも「/posts/2」でもshowアクションにいくようにすることができます。
「posts/:id」と書くと「/posts/◯◯」のような全てのURLが該当します。

;id以外もあり得るかも.DBではidではなく、人の名前などある。その場合には、人の名前などもありうる。

「posts/:id」というルーティングは「posts/index」より下に書かなければいけません。
ルーティングは合致するURLを上から順に探します。そのため「posts/index」よりも上に書くと、「localhost:3000/posts/index」というURLは「posts/:id」というルーティングに合致してしまいます。

showアクションでは、URLのidと、idカラムのデータが等しい投稿データを表示する必要があうｒ。
そのためにそれぞれのURLからidの部分1 2を取得する方法がある

コントローラのアクション内では、ルーティングで設定したURLの「:id」の値を取得することができます。その値はparamsという変数にハッシュとして入っています。
params[:id]と

getsのidの値を取得する
paramsという値

def show
	@id = parmas[:id]
end

変数paramsに、、{id: 1}といハッシュが入っている
アクセウしたサイトのidを取得できる。


showアクションで変数@postを定義し、idカラムの値がparams[:id]と等しい投稿をデータベースから取得して代入します。
@postをshow.html.erbで表示することで、各URLに対応した投稿のデータが表示されるようにしましょう！


showアクションで変数@postを定義し、idカラムの値がparams[:id]と等しい投稿をデータベースから取得して代入します。

posts_controller.rb
def show
	@post = Post.find_by(id: params[:id])
end


@postをshow.html.erbで表示することで、各URLに対応した投稿のデータが表示されるようにしましょう！
<div class = "posts-show-item">
	<%= @post.content %>
		<dif class = "post-time">
			%=@post.created_at %>
		</div>
	</div>


詳細画面へのリンクを作成する。

投稿一覧ページに、各投稿の詳細ページへのリンクを作成しましょう。
各投稿の内容の部分をクリックすると詳細ページに移動できるように、link_to(post.content, "/posts/#{post.id}")とします。

新規投稿ページは、「localhost:3000/posts/new」というURLでアクセスできるようにしましょう。
そのためにルーティング、アクション、ビューを追加しましょう。
アクションは、newアクションとしましょう。

HTML & CSSのレッスンで学習した<textarea>タグや<input>タグを用いることで入力フォームを作成することができます。
送信ボタンにはtype="submit"と、value="投稿"を指定することに気をつけましょう。
<textarea></textarea>

<input type="submit" value="投稿">

フォームの投稿ボタンを押すと、Rails側に投稿データが送信されます。
今回はcreateアクションを用意して、受け取った投稿データをデータベースに保存するようにします。
createアクションのURLは「/posts/create」としましょう

createアクションのルーティングを設定しましょう。
今までルーティングを書く際に「get」と書いてきましたが、フォームの値を受け取る場合は「post」とする必要があります。（この「post」はPostモデルの「Post」とは関係ありません。）
通常は「get」、フォームの値を受け取るときは「post」というように覚えておきましょう。

form_tagメソッドを用いると、フォームに入力されたデータを送信することができます。form_tagは、「form_tag(送信先のURL) do」のように送信先のURLを指定します。
これによって、<input type="submit" ...>のボタンを押した時に、指定されたURLにデータが送信されます。

form_tagメソッド
<%= form__tag("送信先のURL") do %>
<textarea></textarea>
<input  type="submit" value="投稿">

form_tagメソッドの注意点
<%= %>で囲む
do と　end の中にフォームを作る
※該当するはいんの<div></div>の外側でも内側でも問題はない。
<div はクラスを定義するためにくっついているだけのもの。ソレ以

フォーッ無の送信先を指定ても、createアクションに対応するビューをつくる、投稿を保存する、の2つの挙動を追加する

Createアクションではビューを用意するかわりにリダイレクトを用いて渡欧お香一覧画面に転送できる


他のURLに転送（リダイレクト）するには、redirect_toメソッドを用います。
redirect_toは「redirect_to(URL)」とすることで、そのページに転送することができます。

def create
	redirect_to("/posts/index") #指定したURLに転送する
end


投稿を保存する
1.投稿がcreateアクションに送信されるようにする
2.送信された内容を受取保存する

<textarea>タグにname属性を指定すると、入力データを送信することができるようになり、name属性の値をキーとしたハッシュがRails側に送られます。
<textarea name="content"></textarea>

→{content: "Rails勉強中!"}

name属性を指定したフォームに入力されたデータは、コントローラのアクション内で受け取ることが可能になります。
フォームのデータは、変数paramsで受け取ります。paramsはname属性に設定した文字列をキーとしたハッシュになっています

def create
	params[:conten] #{content; "rails 勉強中"}というハッシュが代入されている
end



実際に保存する手順に関しては、「rails console」で学んだことを思い出しましょう。
以下の図のように、Postインスタンスを作成する際にparams[:content]を用います。そのPostインスタンスを保存することで投稿機能の完成です！

def create
	@post = Post.new(content: params[:content])

	@post.save
	redirect_to("/posts/index")
end

入力データを受け取るためのparamsはURLからidの値を取得するときにも使いました。
paramsは以下の2通りの使い方があるので、整理して覚えておきましょう。


①「:○○」を使ったルーティングのURLから値を取得する
②「name="○○"」が付いたフォームの入力内容を受け取る


投稿の並べ替え
orderメソッドを用いることで、投稿一覧を並び替えることができます。
order(カラム名: 並び替えの順序）のように使います。並び替えの順序には、昇順（:asc）と降順（:desc）のどちらかを指定できます。
created_atを基準に降順（:desc）に並べ替えると、新しいものから順番に表示するようにできます。

def index
	@post=Post.all.order(created_at: desc)
end


pposts = Post.all.order(created_at: :desc)
の" :desc"のコロンは、そういういもの。（そのうちRailsが深く理解できてくれば、わかるようになる。


投稿の編集

1.編集したい投稿を取得
2.その投稿のcontentの値を上書き
3.でーたべーに保存

post.content = "新しい値"とすることで、投稿のcontentの値を上書きすることができます。


その投稿に対してdestroyメソッドを用いることで、データベースから削除することができます。

新しいページを容易　　　　- ルウには
ルーティングと、アクション、それからビューが必要


どの投稿の編集ページか判別するために、投稿編集ページのURLには編集したい投稿のidを入れるようにします。そのため、showアクションと同様にルーティングにidを含むようにします。
また、postsコントローラ内にeditアクションを作成し、対応するビューとして、edit.html.erbも作成しましょう。


URLにidを含めることでどの投稿の編集ページを表示するか特定できるようになります。

get "posts/:id/edit" => "コントローラ名#アクション名"
@post.idとすると投稿データのidを取得することができるので、 変数展開を用いてURLにidを含めるようにします。
link_to("編集", "/posts/#{@post.id}/edit")


ルートのURLはスラッシュの数で見ている。なので、 /a/b/cであれば /a/:id にはかからない。スラッシュの数が少ないから
<textarea>タグでは「<textarea>初期値</textarea>」のようにタグで囲んだ部分を初期値として設定できます。

updateアクションはフォームの値を受け取るので、ルーティングを
getではなく、postにする必要があります。
また、特定のidの投稿を更新するので、URLにidを含むようにしましょう。
投稿を編集した後は投稿一覧ページにリダイレクトさせるので、ビューは
不要です。

フォームで入力した内容をデータベースに保存するためには、フォームのデータをupdateアクションに送信する必要があります。
新規投稿ページを作ったときと同様に、form_tagメソッドを用いて、送信先を指定しましょう。


update アクション
- フォームの保内容の保存
- 投稿一覧画面への転送

post "posts/:id/update" => "posts#update"

ページの遷移
def update
	redirect_to("/posts/index")
end

[フォームの保存]
フォームで入力した内容をデータベースに保存するためには、フォームのデータをupdateアクションに送信する必要があります。
新規投稿ページを作ったときと同様に、form_tagメソッドを用いて、送信先を指定しましょう。

<=% form_tag("/posts/#{@post,id}\update") do%>
form_tagメソッドで送信先を指定する
<textarea><%=@posts.content %></textarea>
<input type="submit" value="保存" >
<%end%>


投稿の内容を更新する手順
1.URLに含まれたidを用いてデータベースから投稿データを取得する
2.フォームから編集内容を受取、投稿データを更新する

1.投稿データの取得
updateアクションのURLにはidが含まれているので、そのidを用いてデータベースから投稿データを取得する
続いて<textarea>タグにname属性を指定し、フォームの入力内容が変数paramsに代入されてupdateアクションに送信されるようにします。
updateアクションでは、フォームから送信された値を
params[:ocntent]で受取、 @post.content = params.[:contentで投稿データの内容を更新する
<%. form_tag("/posts/#{@post.id}/update") do %>
 <textarea name="content"> </textarea>

<% end %>

def update
	@post = Post.find_by(id: paramas [;id])
	@post.content = params[:content](フォームの値を受け取る)
	@post.save

end

投稿の削除
destroyアクションを追加
destoroyアクションの機能
1.投稿の削除
2.投稿一覧画面への転送

destroyアクションでもルーティングはgetでなくpostにする

post "posts/:id/destroy" => "posts/destroy"

def destroy


	redirect_to("/posts/index")
end


"get"  と"post"の使い分け
get:
	データベースを変更しないアクション

post:
	データベースを変更するアクション


削除用のリンクを作成
 lint_toを用いてdestroyアクションへのリンクを作る
lint_to("削除", ";posts/#{@post.id}/destroy")のようにっ書くと、get "posts/:id/destroy"のように書かれたルーティングを探してしまう。なのでpost用のlink_toの書き方を見る
kink_toの第三引数に{method: "post"}を追加することで、postとして定義されているルーティン部にマッチするようになる

データベースからの削除
find_byでdataを取り出して、destroyで削除

@post.find_by(id: params[:id])
@post.destroy


不正な投稿絵＾たを制限する機能を作る
からの投稿 140文字を超える当オックをできないようにする

バリデーション
;不正なdataがデータベースに保存されないように、エータをチェッkする仕組みのこと


バリデーションの書き方

models/post.rb

xlass Post > ApplicationRecord
	validates *検証するカラム名, {検証刷る内容}
end

Postモデルのバリデーション
class Post > ApplicationRecored
	validates :content, {presence: true}

end

投稿の文字数を制限する

バリデーションでは、値あｇ存在しているだけでなく、文字数もチェックできる
length {maximum; 数値}

class Post < ApplicationRecord
	validates :content, {length: {maximum: 140}}
end

バリデーションで検証　　　　- ルウ内容はじつはハッシュとなっており、図のようにコンマで区切ることで、複数して刷ることっができる

class Post > applicatoinRecored
	validates :content, {presence: true, length: {...}}

end

  validates :content, {presence: true, length: {maximun: 140}}

ユーザー登録において値の重複がないかのチェック
class User ApplicationRecord
	validates :email, {uniqueness: ture}
end

値が空でないかのチェックは presence: true

重複がないかのチェックはuniqueness: true

バリデーションの結果によって遷移するページが異なる使用にする。



投稿をっデータベースに保存するために使用したsaveメソッドは、保存に成功した場合はtrue
失敗した場合にはfalseを返す

投稿を保存の有無で違いをつける
saveメソッドの戻り値をif文の条件式とする

def update
	if @post.save
		#保存できた場合
		redirect_to("/posts/index")
	else
		#保存できなかった場合
		redirect_to("/posts/#{post.id}/edit")
	end
end


投稿失敗時に直前の編集内容を消さないようにする
投稿の更新が失敗した時に、直前の投稿内容が、フォームの初期値となるようにしましょう。
編集内容が消えてしまう仕組み
1.投稿失敗時にeditアクションに転送する
def update
	redirect_to("/posts/#{@post.id}/edit")
end
2.データベースから編集前のdataを取得している
def edit
	@post = Post.find_by(..)
end
3.editアクションで取得したデータを標示している
<textarea> <%=@post.content %> </textarea>


→updateアクションのppostには直前の変数内容が入っているので、
この@postをedit.html.erbで利用できるようにすれば、直前の編集内容を表示できるようになる
editアクションを経由せず、updateアクションからedit.htmerbをよく説表示すればよい


renderメソッドを用いれば、別のアクションを経由せずに直接ビューをひょうじすることができます
render("フォルダ名\ファイルメイ")のようにredirect_toメソットを使った場合と違い、そのアクション内で定義した@変数をビューでそのままあつかうことができる
renderの引数はあくまで「ファイルパス」なので、先頭に" / "をつけない。URLではないから

def update
	@post = Post.find_by(id: params[:id])
	@post.content = params[:content]
	render("posts/edit")
end

このときの
下でfalseの場合（入力文字が140文字を超えているなど）のとき、@post.content = params[:content]の内容は141文字以上の文字のまま。post.save
def update
    @post = Post.find_by(id: params[:id])
    @post.content = params[:content]
    if @post.save
      redirect_to("/posts/index")
    else

      # renderメソッドを用いて、editアクションを経由せず、posts/edit.html.erbが表示されるようにしてください
      #redirect_to("/posts/#{@post.id}/edit")
      render("/posts/edit")#postコントローラーの下のeditを実行しろ、というパス。
  							# route経由でなく、そのままパスを呼んでいる。
  							# get "posts/:id/edit" => "posts#edit"URLを経由しないから、idが拾えない→だから、editの編集前のものが呼び出されない。=入力内容@post.content = params[:content]がそのまま残る
  							# URLを通らないとしても、データベースを通らないわけではない。コントローラー上でデータベースを参照するようにしてあれば、データベースは参照される。
  							# URLを通るとは、どういういことでしょうか

    end
  end


エラーメッセージの取得
saveメソッドを呼び出した際にバリデーションに失敗すると、Railsでは自動的にエラーメッセージが生成されるようになっています。@post.errors.full_messagesの中に、エラー内容が配列で入ります。

rails  console
> post = Post.new(content:"")
> post.errors.full_messages >[] #保存失敗前にはからの配列が入っている
> post.save => false #保存失敗
>post.reeors.full_messages => ["Contentを入力してください"] #保存失敗後には、エラーメッセージが入っている.

<% @post.errors.full_messages.each ddo ~message~ %>


うまく言った場合にサクセスメッセージを表示する
フラッシュ;
	ページに１度だけ表示されるメッセージ

フラッシュが表示された後、ページを更新したり、別のページに移動したりすると、フラッシュは表示されなくなる

Railsではフラッシュを表示するために、特殊な変数flashが容易されている。アクションで変数flash[:notice]に文字列を代入すると、flash[;notice]をビューで使うことができる。
変数flashには1度だけ表示されたあと、自動で削除されるようになっている。
flashはいろいろな箇所で共通で使用するので、application.html.erbで表示する

[posts_controller.rb]
def update
	if @post.save
		flash[:notice]= "標示したい文字列"
	end

end

[layouts/applicatoin.html.erb]
<% if flash[:notice]%>
	<div class="flash">
		<%=flash[:notice]%> #flashメッセージが存在する場合にのみ表示する
	</div>
<%end&>


新規投稿や削除でもメッセージを表示する
新規投稿に失敗した場合に、再び新規投稿ページを表示するようにする
def create
	if @post.save
		redirect_to("/post/index")
	else
		redirect_to("/post/create")
	end


新規投稿においても、エラメッセージと直前の内容を表示する

[post_controller.rb]

def create
	@post = Post,new(content: params[;content])

	render("posts/new") #new アクションを経由せずにnew.html.erbを直接表示する
end

[posts.new.html.erb]

<% @post.errors.full_messages,each do |message| %>
	<div class="form-error"<
		<%= message %> #errorメッセージの表示部分
	</div>
<%end&>

<textarea> <%= @post.content %></textarea> #直前の投稿内容を表示する

new.html.erbで変数@postを使用するようにしますが、newアクションではまだ変数@postが定義されていません。なのでnewアクション経由（localhost:3000/posts/newというURL）でアクセスしたときにエラーが出てしまいます。図のように@postにPost.newを代入しておけば、うまく動くようになります。

def new
	@post = Post.new
end


下のdestroyの場合には、if elseで削除できなかった場合のエラーを出すほうが実際には親切。
サーバーとのやりとりや、存在しないidを指定されたときなど、削除できない場合も存在するから
def destroy
    @post = Post.find_by(id: params[:id])
    if @post.destroy
      flash[:notice] = "投稿を削除しました"
    end
    # 変数flash[:notice]に、指定されたメッセージを代入してください
    redirect_to("/posts/index")
 	end

end



##ユーザーを作る
- ユーザー一覧
-ユーザーの詳細
-ユーザーの新規登録
-ユーザーの情報編集

rails consoleの場合には、データベースをコントロール
railsの場合には、全体的なコントロール。
またデータベースを変更する場合には、GUIツールを使う場合のほうが多い。

モデルとテーブルの作成
rails g model User#モデル名 name(#カラム名):string(#データ型) email:string(#データ型)
後のカラムとデータ型のセットは複数並べられる

rails db:migrateデータベースに変更を反映させる

table似】データを保存する手順
newメソッドでUserモデルのinstanceを作成
saveメソッドでuserstableに保存ん
rails console
> user = User.new(name: "hogehoge", eamil:"hogehoge@iii")
> user.save

ユーザー機能の追加
ユーザーの一覧
ユーザーの詳細
ユーザーの新規登録
ユーザーの情報編集


ユーザー一覧
データベースに保存されている湯～あが全て表示されるようにする
ヘッダーにユーザー一覧ページヘのリンクを追加する
ユーザーに関するusersコントローラとユーザー一覧ページのindexアクションを作る

コマンドで使うときは、なにもない時に使う
コッ万土でやるのは、前回までと同じような形でやっているのが、講義の内容になっている
なのでコマンドを使わなくても、データベースに内容を


rails g controllerコマンドを用いて、コントローラと一覧ページのアクションを作成するときに生成されるもの
- htmlの部分viewの下のhtml
- userコントローラ
- usersのscssファイル（cssのファイル）
の2つぐらいのファイルができる。

コマンドで作るとわからなくなる。自分が何を作り出したのか


@posts.each do |post|
eachのあとにはピリオドいらない
データベースからユーザーをひろってくるのは、find_by(params[:id])

ユーザーのしに登録機能
投稿の新規作成機能と同じ
1.登録ページの作成
2.ユーザーの保存
3.作成エラーメッセージの表示

登録フォーム
複数行の入力フォーム<textarea>タグ
ユーザーをとメールアドレスは1行の入力フォームで十分1行のフォームは<input>タグｗお用いて作成
<input>あtがうは終了タグ
が不要

<p>ユーザーを</p>
<input>
<p>メールアドレス</p>
<input>
<input type="submit" value="新規登録">


コントローラとアクション名の一致させておいたほうがわかりやすい、という考え方。
viewファイルの下のusers >> index.html.erbは
アクション名だけ、表示されるURLではない
→ get "signup"(#URL名) => "users#index"(コントローラとアクション名）
URLは実際のユーザーに表示されるもの

<li>
  <%= link_to("新規登録", "/signup")%>
</li>

→このときの第二引数は、URL.
コントローラとアクション


ユーザーの保存
フォームの送信先をuser/createおとしてユーザーを保存したあとには、ユーザーの詳細ページにリダイレクトするように
フォームに入力された値を送信するには、name属性を指定する必要がある（ex. name="contents")
name属性の値が送信されるハッシュのキーにあるため、データの内容がわかりやすくなるようなname属性をそれぞれつけるようにする

<input name = "name">
<input name= "email">

送信されるparamsの中身｛name:"hogehoge", email"hogehoge@iii"}
新規登録ボタンを押す→createアクションへ

フォームの初期値
<inputタグでは" vlue "属性が　- 対が初期値になる。vaul
value 属性のなかにrubyのコードをつ買うには<%= %>を用いてvalue-"値" の中にRubyコードwお埋め込む

edit
updateアクションを作成する

ユーザー編集ページの　　　　- 買う性
変更の保存
サクセス・メッセ＾じの表示

マイグレーションファイルのみの作成
tableに画像のカラムを追加するために、コマンドを実行する
rails g migration ファイル名
rails g migration add_image_name_to_users

格納されるフォルダは、db/migrate/20170427053118_add_image_nmae_to_users.rb
→ファイルメイの先頭に作成日時が追加される

# rails g model User image_names:stringであると、モデルとマイグレーションファイルの両方が作成される

migrationファイルを生成しただけでは不十分
テーブルに変更を加えるためには、マイグレーションファイルのなかのchangeメソッドの中に変更内容を書く必要がある
rails db:migrateコマンドは、changeメソッドの中身を実行するためのもの

これまで「rails g model」によって生成されてきたマイグレーションファイルは、changeメソッドの中身が自動生成されていました。
なので、マイグレーションファイルの中身を特に変更すること無く、そのまま「rails db:migrate」コマンドを実行することでデータベースに変更を反映することができていました。

今回は自分でchangeメソッドの中身を書く必要があります。
カラムを追加する場合には左の図のように、
「add_column :テーブル名, :カラム名, :データ型」とします。
changeメソッドの中身を追加したら、「rails db:migrate」でデータベースに変更を反映します。


ユーザー登録時に初期画像を保存するようにする
ユーザー登録時に、image_nameカラムの値が「default_user.jpg」になるようにしましょう。
createアクション内の@userを定義しているところで、newメソッドの引数としてimage_nameを追加するようにします。

def create
	@user = User.new(
		name:params[:name],
		email:params[:email],
		image_name: "default_user.jpg"
	)
	if @user.save

end

上記のように登録してみる

ユーザー画像を表示するためには、今まで画像を表示してきた時と同様に、HTMLの<img>タグを用います。
画像はpublic/user_imagesフォルダに保存されているので、src属性の値は「/user_images/ファイル名」とする必要があります。
Rubyのコード部分は<%= %>で囲む必要があることに注意しましょう。

<img src="<% "/user_images/#{@user.image_name}"%>">
#/user_images/default_user.jpgのようになる
<img src ="<%"/user_images/#{@user.image\name}" %>">


ユーザーが画像を設定できるようにする
左の図のように<input>タグに「type="file"」を追加することで、右の図のように画像ファイルを選択するボタンを表示することが出来ます。
また、ここではname属性は「image」としておきましょう。


画像の送信は特殊なので、form_tagに{multipart: true}を追加する必要があります。
詳しく理解する必要はないので、「画像を送信したいときには{multipart: true}をつける必要がある」ということだけ覚えておきましょう。

＜％= form_tag("...", {multipart: true}) do %>
画像を送信したいときなどには、multipart: ture


画像の保存
updateアクション
ファイル名を保存
+
publi/user_images内に画像を作成

Rubyのコードでフェイルを保存刷る方法
rails console

Rubyのコードでファイルを扱うには、Firleクラスをもちいる
File writeメソッドをもちいる
File.write("ファイルの場所!, !ファイルの中身)
File.write("publi\sample.txt", "Hello World")


フォームで送信された画像を保存してみる
。updateアクションに「以下の機能を追加
- ファイル名をデータベースの保存
- publiフォルダ内に画像を作成

name やemailと同様に、@user,image_nameの値を上書きする
def update
	@user = User.find_by(id; params[:id])
	puser.name=params[:name]
	puser.email=params[:email]
	pser.image_name="#@user.id}.jep"

	if @user.save

end

##publiフォルダ内に画像を作成

画像ファイルも他のnameやemailと応用に、params[:image]とすることで受け取ることができる
params[:image]のなかには送信された画像ファイルに関する情報が入っている。

画像を保存するには、画像データをもとに、画像ファイルを作成　　　　- ルウ必要がある
Fileを作成するためには、Fileクラスをもちいる。
ただし画像データは特殊なデータであるから、File.writeではなく、File.binwriteをもちいる
変数imageに対して、readメソッドをもちいることで、画像データを保存することができる

def update
	@user.image_name= "#{@user.id}.jpg"
	image = params[:image]
	File.binwrite("public/user_images/#{@user.image_name}", image.read)
	// image.readはFileの中身＝画像データ

end

画像が存在するか反帝する
保存する処理は、画像データが送信ｓれた場合っだけにする
画像が送信されたときにだけ、画像をこうしんするように、if文を追加する

def update

	if params[:image] //画像が送信されているかを判定する
		@user.image_name = "#{puser.id}.jpg"
		image = params[:image]
		File.binwrite("...", image.read)
	end

end


## ログイン・ログアウト機能

ログイン:
	サイトを操作しているユーザーが誰であるかを判別できる状態のこと


ルーティング
アクション
ビュー
get "login" => "users#login_form"

def login_form

den

login_form.html.erbにパスワード用のフォームを追加する
input タグのtype属性をpassword とすると、入力したパスワードが伏せ字となるパスワードようのフォームになる
<p> パスワード</p>
<input type="password">

パスワードカラムの追加
rails g migration add_password_to_users
→"add_password_to_users"というファイルメイの毎グレーsyんファイルを作成
マイグレーションファイルのなかっ見は右の図のようにし、
rails db:migrateを実行しておく

def change
	add_column :users#テーブル名, :password#カラム名, :string#データ型
バリデーションをせてい
ユーザーの情報には必ずpasswordの値が存在してほしい
passwordのカラムにもバリデーションをかかえる
presence; 存在するかどうかのバリデーション

class User < ApplicationRecord
	validates ;password, {presence: true}
end


フォームの値を送信する

フォームから送信された値を受け取るために、ルーティングとアクションを追加する

ルーティングはpost
フォームの値を送信するから
route.rb
	post "login" = users#login"

users_controller.rb
	def login

	end

フォームの送信先を指定する
 form_tagメソッド
 ※フォームにん有力された値がRails側に送信されるように、inputタグいname属性を追加する

<% = form_tag("/login") do %>
	<p> メールアドレス </p>
	<input name="emali">

	<P>パスワード</p>
	<input type="password" name="password">
<%end%>

login アクションのルーティング
/loginで2つのルーティングがかぶっているように見えるが
get と　postは異なるルーティングとして扱われるので問題ない

（link_toメソッドではデフォルトでgetのルーティングを探し、form_tagメソッドがデフォルトでpostのルーティングを探します。）

・ 対応するアクションはusersコントローラのloginアクションとなるようにしてください。
・ post URL => コントローラ名#アクション名となるようにしてください。

ログイン
ユーザーの特定
	フォームに入力されたメールアドレスとパスワードはparams[:email]とparams[:password]で受け取れる
	usersテーブルから入力された値に一致するユーザーを取得し、変数@userに代入する
	find_byメソッドは引数をコンマで区切ることで複数の条件からデータベースを検索ｄけいる


def login
	@user = User.find_by(email: params[:emal], password: params[:password])

end


ユーザーが存在する場合と存在しない場合の対処

def login
	@user = User.find_by(^

	if @user
		flash[:notice] = "ログインしました"
		redirect_to ("/posts/index")
	else
		render("users/login_form")
		#ログインページを再表示
	end
end

ログインフォームに入力されたメールアドレスとパスワードに一致するユーザーが存在しない場合は、エラーメッセージを表示する

ログインフォームに入力されたメールアドレスとパスワードに一致するユーザーが存在しない場合は、エラーメッセージを表示しましょう。今回のエラーメッセージはバリデーションのエラーメッセージとは異なり、「find_byメソッドで検索したが、存在しなかった」という結果を伝えるためのものなので、図のように自作する必要があります。



<users_controller.rb>
def login

	if @user

	else
		@error.message = "メールアドレスまたはパスワードが間違っていあす"
		render("users/login_form")
end

<login_form.html.erb>

<%= if @error_message %>
	<div class="form_error">
		<%= @error_message %> #エラーメッセージの表示
	</div>
<% end %>

### 初期値の設定


変数@emailと@passwordを定義し、それぞれにparams[:email]とparams[:password]の値を代入し、フォームに入力した値が初期値となるようにしましょう。また、変数に代入した初期値を表示するためにフォームにvalue属性を追加しましょう。
def login
	if
	else
		@error_message = "~~~"
		@email = params[:email]
		@password = params[:password]
		render("users/login_form")
	end


end


<%= form_tag("/login") do %>
	<p>メールアドレス</p>
	<input name = "email", value = "<%= @email %>" >

	<p> パスワード </p>
	<input type = "password", name = "password", value = "<%= @psswrod %>" >

<%end%>

###ログイン処理の続き

ユーザーを特定したのちいには、そのユーザーの情報を保持し続ける必要がある。


## 変数session

ページを移動してもユーザー情報をほじしつづけるために sessionという特殊な変数をもちいる
sessionに網地に有された値は、ブラウザに保存されｓる
sソレ以降のアクセスでsessionの値を、ブラウザはRailsに送信する

session[:キー名] = 値
sessionに値を導入するときには、user_idをキーとし、値を代入する
@user_idを代入することで、特定したログインユーザーおの情報が保持され続ける


>	def login
>	@user = User.find_by(...)
>
>	if @user
>		session[:user_id] = @user.id
>
>	end


ページを移動しても保持されていることをっ確認するために、ログインしたユーザーのidをヘッダーに表示する

<application.html.erb>

<li>
	<%= session[user_id] %>
</li>



##ログアウト機能
変数sessionのuser_idを削除する
ログイン・ログアウトは、sessionがすべて
session[:user?id]の値を空にする

def logout
	sesson[:user_id] = nil
end

logoutアクションを実装する
ルーティングは、loginと同様に、get ではなく　postとする

get と post
- データベースを変更するときに加え、sessionの値を変更する時にもpostをもちいる
get
	-データベースを変更しない場合
post
	- データベースを変更する場合
	- sessionの値をhんこうする場合

ログアウト後は、ログインページにリダイレクトする


	def logout
	session[:user_id]=nil
	flash[:notice] = "ログアウトしました"
	redirect_to("/login">
	end


###ヘッダーメニューの表示内容を切り替える
ログインお状態でも、ログインページへのリンクがひょうじされるが、ログイン状態では、このリンクは不要

ログイン状態標示する項目
sesson[:user_id]
投稿一覧
新規投稿
ログアウト

ログアウト状態で標示する項目
TwwtAppとは
ログイン



##ユーザー老特に成功したら、そのままログイン状態とする

ユーザー登録時にパスワードを保存する
ユーザー登録フォームに、パスワード用のフォームを追加

<new.html.erb>
<p>パスワード</p>
<input name="password" type="password" value = "<%= @user.password %>" >


ユーザー登録時に、passwordのカラムの値がっていされるようにする
<users_controller.rb>

def create
	@user = User.new(
		name: prams[:name],
		email: params[:email],
		image_name: "defaul_user.jpg",
		password: params[:password]
		)
	if @user.save
		session[:use_id} - @user.id
		#新規登録時に、作成したゆ～～ざーがそのままログイン状態になるようにする
end


ユーザー名を標示する
ログインしちえるユーザー名の表示
session[:user_id]の値を本に、ログイン中のユーザーの情報をデータベースから取得する

find_byメソッドで、usersテーブルからidの値が、session[:use_id]と等しいユーザーを種痘kし、変数に代入する

<layouts/application.html.erb>

<% current_user = User.find_by(id: sesson[:user_id]) %>

<li>
	<%= link_to(current_user.name, "/users/#{current_user.id}") %>
</li>

ヘッダーでcurrent_userという変数を定義したが、変数の定義はアクション側でするべき
application.html.erbの仕組み

各アクションに対応したビューファイルは、applicatioin.html.erbの<%= yield %>部分に代入されて表示されている
これにより、applicaton.html.erbは全アクションから呼び出されている

application.html.erbは全てのアクションで呼び出される
そのため、application.html.erbでアクション側の変数を使おうとすると、全アクションで
pcurrent_userを定義する必要がある

各コントローラの全アクションで共通する処理がある場合には、
before_actionを使うと便利
before_actionをもちいることで、アクションが呼び出される際に必ず
before_actionが実行される。これにより、全アクションで共通する処理を
一つ箇所にまとめることができる

全てのコントローラで共通する処理はapplicationコントローラにまとめられる
ログイン中のユーザーを種痘するset_current_userメソッドを停止、before_actionに指定する
こうすると、全コントローラで全アクションで、@current_userを定義できる

before_action :set_current_user

def set_current_user
	@current_user = User.fing_by(id: sesson[:user_id])
end



##ログインしていない場合のアクセス制限

ログインしていない場合でも、URLを直接入力すると、アクセスできてしまう

そこで、、@current_userがいない場合には、ログインページにリダイレクトするようにする
この処理は、他のアクションや他のコントローラでも使いたいので、appicationコントローラとbefore_actionを用いて処理を共通化させる

<applicatoin_controller.rb>

def authenticate_user
	if @current_user == nil
		flash[:notice] ="ログインが必要です"
		redirect_to("/login")
	end
end

上記は全アクションに適用したいわけではないから、、各コントローラの各アクションに指定刷る必要あり

before_actionを特定のアクションでのみ実行する

<users_controller.rb>

before_action :autenticate_user, {only: [:edit, :update}}
#onlyを用いて適用したいアクションを指定する
onlyでアクションを指定するときには、[]を用いて配列形式に

各コントローラは、applicationコントローラを継承しているから、継承元のメソッドを使うことができる


@h変数で定義した変数は同じクラスの異なるメソッド

ログインユーザーがアクセスできないページ

新規登録ページやログインページなど
ログインして

forbid_login_userメソット

applicationコントローラ内にログインユーザwを禁止する意味の
forbid_login_userメソッドを作成する

<application_controller.rb>
def forbid_login_user
	if @current_user
		flash[:notice] = "すでにログインしています"
		redirect_to("/posts/index")
	end
end

<home_controller.rb>
before_action :forbid_login_user, {only: [top]}

<users_controller.rb>
before_action :forbid_login_user, {only: [:new, :create, :login_form, :login}


###ユーザーの編集を制限する（ビュー）
ログインしているユーザー情報のみ制限できるようにする
ログインしていれば、他のユーザーの詳細ページから編集ページにアクセスできる状態
→ユーザー詳細画面の変種リンクを自分の詳細画面のときにだけ表示されるようにする

ユーザー詳細ページで、ログインしているユーザーでｈないあ場合には、編集ページへのリンクを非表示にする

<users/show.html.erb>
<% if @user.id == @current_user.id %>
	<%= link_to("編集", "users/#{puser,id}/edit") %>
<& end &>

ユーザーの変種を制限する（アクション）
直接URLにアクセスすれば、編集ページに入れる
これを防ぐために、ビューでリンクを消すのに加えて、アクション側でも同じ条件をつける

<users_controller.rb>
before_action :ensure_correct_user, {only:[:edit, :update]}
def ecsure_correct_user
	if
		flash[:notice] = "権限がありません"
		redirect_to("/posts/index")
	end
end

to_iメソッド
ログイン中のユーザーのidは@current_use.idに代入、編集したいユーザーのidはparams[:id]に代入されている
しかし、params[:id]絵で取得できる値は文字列であり、
数値である@current_user.idと比較してもfalseとなる
to_iメソッドで@params[:id]を数値に変換する

<users_controller.rb>
before_action :ensure_correct_user,  {only: [:edit, :update]}
def ensure_correct_user
	if @current_user.id != params[:id].to?i
		flash[:notice]="権限がありません"
		redirect_to("/posts/index")
	end
end

### 投稿詳細ページにて誰が投稿したかを標示する
投稿のテーブルに、投稿者のIDカラムを追加する
rails g migration add_user_id?to_posts　を実行しマイグレーションファイルを作成

ファイルの中身は以下のように変更

> class AddUseIdToPosts
>		def change
>			add?column :posts,(テーブル名）,:use_id,(カラム名）,:integer(データ型）
>		end
> end


以上のように定義し、rails sb:migrateを実行する

use_idにもバリデーションを設定
誰が投稿したかいう情報は常にあるべきなので、
models/post.rbにて以下のように設定

	class Post < ApplicationRecor
		validates :user_id, {presence: ture}
	end


### 投稿の際に、ユーザーのIDを保存する

投稿したユーザーは、現在ログインしているユーザーだから、@current_use_idで指定可能


	<posts_controller.rb>
	def create
		@post = Post.new(content: params[:content], user_id: @current_user_id
	end


### 投稿にユーザー情報を標示する
use_idのカラムの値から、そのユーザーの情報を取得する

	posts_controller.rb
	def show
		@post = Post.find_by(id: params[:id])
		@user = User.find_by(id: @post.user_id)

	end

### ユーザー画像とユーザー名を標示する

アクションで定義した、変数@userを利用し、ユーザー画像とユーザー名を表示　　　　- する

	<posts/show.html.erb>

	<div class = "posts-user-name">
		<img src = "<%= "/user_images/#{@user.image_name}" %>
		<% = link_to(@user.name, "/users/#{@user.id}") %>
	</div>


### モデルにインスタンスを定義する

	class Psost < ApplcationRecord

	def
	 puts "こんにちは"
	end

	end

<rails console>
posts = Post.find_by(id:1)
posts.hello
こんにちは


### user インスタンスを定義する

	class Post < ApplicatonRecord
		def user
			return User.find_by(id; self.user_id)
		end
	end

rails console
post = Post.find_by(id:1)
post.user

id: 　


### 投稿一覧にもユーザー情報を表示する

	Q. このとき、postにはuserが紐付いているのか？？

	<% @posts.each do |post| %>
      <div class="posts-index-item">
        <div class="post-left">
          <img src="<%= "/user_images/#{post.user.image_name}" %>">
        </div>
        <div class="post-right">
          <div class="post-user-name">
            <%= link_to(post.user.name, "/users/#{post.user.id}") %>
          </div>
          <%= link_to(post.content, "/posts/#{post.id}") %>

	A. 投稿に紐づくユーザーの情報は、よく使用するので、簡単に使用するメソッドにする
	railsでは、モデル内にインスタンスメソッドを定義することがでっきる。Postモデル内に定義したインスタンスメソッドは、
	postインスタンスに対してもちいることがｄけいる。
	Postモデルに、userメソッドを定義する

	models/post.rb


	def user
		return User.find_by(id: self.user_id) // selfはインスタンスメソッド内で、そのインスタンス自身を指す
	end




### ユーザー詳細ページに投稿を表示する

ある条件に合致する「複数の」でー田を取得するには、whereメソッドをもちいる
whereメソッドでデータを取得したばいい、
それぞれのデータは配列に入っている

	rails console
	> posts = Post.where(user_id:1)
	// user_idが1である投稿おｗ全て取得する

Userモデルにpostsメソッドを定義する

	<models/user.rb>
	class User < ApplicationRecord

	def posts
		return Post.where(user_id: self.id)
	end

	end

rails console
> user = User.find_by(id; 1)
> user.posts //postsメソッドを呼び出せる

### 投稿を表示する

	<users/show.html.erb>
	<% @user.posts.each do |post| %>
	 //表示する内容を各
	<% end %>


### 投稿者だけが編集できるようにする

	posts/show.html.erb

	<% if @post.user_id == @current_user.id %>

		<%= link_to("編集", "/posts/%{@post.id}/edit" %>
		<%= link_to("削除", "/posts/%{@post.d/destroy2, {method: "post"}) %>
	<% end %>

postsコントローラ内に、[ensure_correct_user]メソッドを用意する

before_actionをもちいることで、edit, update, destroyのアクションで適用する

	before_action :ensure_correct_user, {only: [:edti, :update, :destroy)}

	def ensure_correct_user
		@post = Post.find_by(id: paramas[:id])
		if @post.user_id != @current_user.id
			flash[:notice] = "権限がありません"
			redirect_to("/posts/index")
		end
	end

## いいね機能をつくる

### いいね機能の仕組み

どのユーザーがどの登校にいいねしたかをデータとして管理する機能
データベースにlikesテーブルを作成する

rails g model Like user_id:integer  post_id:integer
//マイグレーションファイルを作成

rails db migrate

//データベースに変更を反映させる

バリデーションの追加

user_idとpost_idの両方がつねに存在していることを確認

models/like.rb

	class LikesController < Applicationrecord
		validates :user_id, {presence: true}
		validates :post?id, {presence: true}
	end


### railsconsoleでデータを作成する

	rails console
	like= Like.new(user_id; 1, post_id:  2)
	like.save

	// このときの[Like]はテーブル名


### 現在ログインしているユーザーがいいねしたかどうかで表示を変える

作成したlikesコントローラに、新たにLikeデータを作成するためのcreateアクションを用意しましょう。createはデータベースにデータを作成するアクションですので、ルーティングには「post」を用います。
URLの部分は「どの投稿をいいねしたのか」という情報を送信するために、「likes/:post_id/create」としましょう。

いいねした ＝いいね済み
いいねしていない = いいねしていません

	posts/show.html.erb

	<% if Like.find_by(user_id: @current_user.id, post_id: @post.id) %>
		いいね済み
	<% else %>
		いいねしていません
	<% end %>

### いいねボタンの準備
likesコントローラを作成して、likeデータを作成するためのアクションを追加する
今までhコントローラは rails g corotoller コマンドで作成してきたが、
コマンドをも陥るとビューファイルなでも自動作成される
今回はそれのビューファイルが必要ないので、コントローラを手動で作成する
controllersフォルダ内にlikes_controller.rbとういファイルを新規作詞絵する

### createアクションを定義する

	likes_controller.rb
	class LikesController < applicationController

		def create
		end
	end

createはデータベースにデータを作成するアクションであるから、ルーチィングにpostをもちいる
URLの部分はどの投稿にいいねしたのか、というじょうほうをそうしんするために、likes/:post_id/createとする


	routes.rb

	Rails.application.toures.draw do

		post "likes/:post_id/create" => "likes%create" //コントローラ名#アクション名
	end

### createの中身

	likes_controller.rb

	def create
		@like = Like.new(
			user_id: @current_user.id,
			post_id: prams[:post_id}
		)
		@like.seve
		redirect_to("/posts/#{params[:post_id]}")
	end


	routes.rb

	Rails.application.routes.draw do
		post "likes/:post_id/create" => "likes#create

	end


	posts/show.html.erb

	<% if Like.find_by() %>
		いいねすみ
	<% else %>
		<%= link_to("いいね", "/likes/#[@post.id}/create", {method; "post"}) %>
	<% end %>

### いいね取り消しボタンをつくる削除おする

現在ログインしているユーザーがあ其の登校をいいねしているという記録を

### destroyアクション

likesControllerにdestroyアクションを作成

	likes_coontoroller.rb

	def deftroy
		@like= Like.find_by(
			user_id: @currene_user.id,
			post_id: params[;post_id]
		)
		@like.destroy
		redirect_to("/posts/#{params[:post_id]}")
	end


	routes.rb

	post "llikes/:post_id/destroy" => "likes#destroy"


	posts/show.html.erb

	<%= link_to("いいねずみ!, "/likes/#{@post.id}/destroy", %>

### いいねボタンをアイコンにする

Font Awesome

をもちい、いいねアイコンをハートにする

胸痛のHMTMLはapplication.html.erbに記入う

application.html.erb

<!DOCTYPE html>
<html>
	<head>

		<link rel="stylesheet" href="hhtps://maxcdn ">
	</head>


ハートにするには

	<span class="fa fa-heart"> </span>

	posts/show.html.erb
	<%= link_to("<span class="fa fa-heart"></span>", "likes/.." %>

### html要素に対してlink_toメソッドを使う

HTML要素に対してkink_toメソッドを柄にうには、<% link_to(URL) do %> と<%end %>の間にHTML要素を記入する

	<% link_to(URL) do %>
		<htmlのコードを気欝する
	<%end %>

	<%= link_to("/likes/#{@post.id}/create", {method: "post"} do %>
		<spann class="fa fa-heart  like-btn"></span>
	<% end %>


### いいねの数を表示する

	rails console

	Like.allcount

	Like.where(post_id: 1).count


### いいねした登校の一覧を表示する

あるユーザーがいいねしたおう投稿を一覧で表示する

ユーザーに関するページを作成するから、likesコントローラーではなく、usesrsControllerにお気に入り投稿一覧ページを表示するためのlikesアクションをつくる


	routes.rb

	Rails.application.tuoress.draw do

		get "users/:id/likes" => "users#likes#
	end

	users_controller.rb

	def likse
	end

### likesアクションを完成させる

	users?controller.rb

	def likes
		@user = User.find_by(id: params[:id])
		@likes = Like.where(user_id: @user.id)
	end

	users/likes.html.erb

	<% @likse.each do |like| %>
		<%post = Post.find_by(id: like.post_id) %>。
	<% end %>

## パスワードの利用法

今までのままでは、usersテーブルにパスワードが通常の文字列うで保存されている


安全性の高いパスワード


### gemを利用し、gemというツールを必要とする

gem Ruby Railsというパッケージ化したもの

bcrypt 暗号化するためのgem

railsにはインスt.miyazawa－るしたgemを記述するGemmfileというファイルが存在する
gem "geの名前",

	Gemfile
	gem 'rails', '5.0.3'
	gem 'puma', '3.6.2'
	gem 'sass-rails', '5.0.6'

rails newコマンドで生成されたgemfileにはすでにいくつかのgemっがインストールされている
Gemfileの下にあるgemfile.lockというファイルは自動でサウk生されるファイルなので編集する必要はありません

gem 'gemの名前', '5.0.3'
// バージョンを指定ひない場合最新のバージョンがインストールされる

	gem 'bcrypt'

を1行追加する
ターミナルにて以下の行を実行すると、書かれたgemをインストールすることができる

	bundle install

### has_secure_password

bcryptをインストールすると、has_secure_passwordというメソッドが
使えるようになる
.パスワードを扱うUserモデルに、追加する。そうすると、自動的にパスワードをお暗号化してくれる

user.rb

	class User < ApplicationRecord
		has_secure_password
	end


### password_digestカラムを追加する

passwordカラムには保存せず、password_digestカラムに保存することになっている

usersテーブルにはpassword_digestカラムが発生していないので追加する
passwordカラムは必要ないので削除する


一つのマイグレーションファイルでは、複数のカラムを変更刷ることが可能


	def change
		add_column :users, :image_name, :string
		add_column :users, :password, :string
	end

マイグレーションファイルの作成

	ターミナル

	rails g migration change_users_columns


	def change
		add_column :users,  :password_digest, :string
	end


パスワードカラムの削除


	def change
		add_coumn :users, :password_digestt, :string
		remove_column :users, :password, :string

	end

	rails db;migrate



### ログインの設定の変更
password_digestからログインできるように変更する


has_secure_passwordメソッドを有効にすると、authenticateメソッドをしようできるようになる
authenticateメソッドは渡された引数を暗号化し、password_digestの値と一致するかどうかを判定してくれうｒ


	users_controller.rb

	def login
		@user = User.find_by(email: params[:email])
		if @user && @user.authenticate(params[:password])

		end
	end





## Git

Gitは開発において、複数人での共同開発をスムーズにするもの

### Gitの準備

Gitはターミナルで操作する

Gitを使う準備として、

	git init
	// initはinitializeの略、初期化を意味する


を実行


### 共同開発とGitの役割

共同開発のステップ

1. コードを変更
2. 共有の準備
3. 共有する

上記の **共有**の場面でGitは活躍する

共有するファイルを選択するには

	git add "変更のあるファイル名"
	//ex. git add index.html

### 選択したファイルを記録する

選択したファイルをメッセージ付きで**記録**することで、共有する準備が完了する

	git commit -m "メッセージ"
	// ex. git commit -m "Create index.html"

このように記録することを**コミット**という
メッセージは、**コミットメッセージ**という
メッセージはコミットがどのような内容かわかるような内容にする


### 共有の仕組み

具体的共有としては**リモート**という共有ファイルの置き場を利用する

リモートにファイルをアップロードしたり、リモートからファイルをダウンロードすることで、開発者同士がFileを共有することができる


リモートは自分で用意する

### リオートの登録

リモートにアップロードするには、そのリモートのURLを用意する
リモートに登録するさいには名前をつける必要がある。一般的には**origin**とすることが多い

	git remote add "リモート名" "URL"
	// ex. git remote add origin https://pro


### プッシュ：リモートへのファイルアップロード

	git push oringin master
	// git push "git remote add のときにつけたリモート名" master

### プル：リモートのファイルのダウンロード

	git pull origin master
	// ex. git pull "リモート名" master


### ここまでの流れ

add → commit → push → pull

### Gitで重要なこと
共同開発では自分が行った開発内容を把握して、変更のなかで相手に共有すべき部分を選択することが重要

### 変更したファイルの把握
自分が変更したFileを把握する

	git status


### 変更内容まで把握する

	git diff

コードを変更した部分では、
- 変更前のコードが**赤色**
- 変更後のコードは**緑色**

で表示される


変更を確認できれば、git addとすればよい


### addしたFileの確認

	git status

- addされたFile：緑色
- addされていないFile：赤色

### わかりやすいコミットメッセージを書く



### コミット履歴を表示する

他人のコミットメッセージを確認する

	git log

コミットメッセージに加えて、変更内容も見たければ、

	git log -p

- 上下キーで表示範囲を変更できる
- Qキーで終了

# Java

## Java
- 大規模システム、ウェブアプリケーション、スマートフォンアプリなどあらゆる場所で活躍している。

Javaのうごかし方

	System.out.println（”Hello World");

()の中身を出力せよ、という命令。

#### Javaの構造

	class Main { //クラス部分
		public stati void main(String[] args){ //メソッド部分

		//処理部分。ここにコードを書く。

		}
	}

文末には ;
コメントアウトは //


### データ型
文字列と整数の並び

String 文字列
int 整数

### 変数の利用
変数を利用するさいには、変数を定義するひつようがある。
変数を定義することで、値をいれる箱がつくられる。

Javaの変数の定義
1. 変数に入れる値のデータ型を指定
2.変数の名前を決める

	int number; // "データ型" "変数名"の並び
	String number;

	int number;
	number = 3

	String name;
	name = "Sato";
	// 右の値を、左のものに代入するという意味。数学のイコールにおける「同じ」を意味するものではない


### 変数から値を取り出す
Sytem.out.println()で出力

	int number:
	numver = 10;
	System.out.println(numver);

	String name;
	name = "Sato";
	System.out.println(name);


### 変数の初期化
変数の定義と値の代入を同時に行うこと

	int number = 3;

	String text = "Hello World";

数値が入っているなら、変数も数値と同様に処理可能

	int number1 = 10;
	System.out.println(number + 3);

	int numver2 = 5;
	Sytem.out.ptinln(number1 + number2);

文字列の連結も可能

	String greeting = "こんにちは";
	System.out.println(greeting + "松本さん");

	String name = "鈴木さん";
	System.out.println(greeting + name);

### 変数の更新
一度値を代入した変数に、その後再び上書きをすると、あとで代入した変数によって変数の中身が上書きされる

	String name = "Sato";
	System.out.println(name);

	name = "Suzuki";
	System.out.println(name);

変数を上書きする際には、int number のようには設定しない。すると、**同じ処理内で同一名の変数は定義できないので** Errorになる

	int number = 5;

	number = 5;

### 自己代入
変数x=3である場合に、 xの値に2を足す操作

	int x = 3;
	System.out.println(x);

	x = x + 2;
	System.out.println(x);


#### 自己代入の省略形

	x = x + 10; | x += 10;
	x = x + 10; | x -= 10;
	x = x * 10; | x *= 10;
	x = x / 10; | x /= 10;
	x = x % 10; | x %= 10;

値が1だけのときにはさらに省略できる

	x = x + 1; | x += 1; | x++;
	x = x - 1; | x -= 1; | x--;


#### 変数を使う理由

1. 何のデータ化わかりやすい
2. 同じデータを繰り返し使える
3. 変更に対応しやすい

変数で定義しておけば、その変数を変更すれば、以降の他の場所も変数の変更が反映される


#### 変数の注意点
- よい例
	- 英単語をもちいる
	- 2誤以上の場合には、大文字で区切る（キャメルケース）
- 悪い例
	- 数字開始（数字開始）エラーがでる
	- アンダーバー’（スネークケース）first_name //これはなぜ悪いのかはわからない
	- namae(ローマ字）
	- 名前（日本語）

変数名
どの値が入っているのかわかりやすい変数名にすること



### 数値のデータ型
	int型 整数 5
	double型 小数 3.14

	double number = 5.28;
	System.out.println(number);


### 型変換
+ などの操作は同じデータ型同士でないと実行できない。なので、異なる型同士を演算するときには
型変換をし、型を揃える。

javaには自動の型変換と、手動の型変換がある

自動型変換
String型とint型を足すと、int型に変換される。文字列として結合される。
数値同士の場合
intとint → int型 5/2 = 2
doubleとdouble → double型 5/2 = 2.5

計算時の自動変換
int型とdouble型では、結果はdouble型になる

	System.out.println(5.0 / 2);

	2.5

int型同士の計算

int型同士の計算では小数点以下は切り捨てられる

	int number1 = 13;
	int number2 = 4;
	System.out.println( number1 / number2); // 3


#### キャスト
強制的な型変換
(変換したいデータ型）値 とする

	int number1 = 14;
	int number2 = 4;
	sytem.out.println((double)number1 / number2 ) ;
	// number1の値がdouble型に変換される。その結果、number2もdouble型に変換される
	3.25
	//

### Javaの基本

#### 真偽値

データ型 boolean型
true falseの２つの値歯科存在しない

	boolean bool = true; //データ型 変数名 = 値

#### 比較演算子

	== 正しいかどうか
	!= 正しくないかどうか


真偽値も出力することができるが、ダブルクオテーションはつけない

	System.out.println(true);


#### 大小比較

	x < y
	x <= y

	x > y
	x >= y


#### かつ 、または でない

	&& かつ // x > 10 && x < 30 false
	|| または // x < 10 || x > 30 true (x = 5)
	!= でない // !(x. >= 30) xが30以上でない。つまり、30より小さい



### 条件分岐

	if (条件式) {
		処理;
	}

	()内にっ条件、{}に処理を書く,trueの場合に実行される式


	int x = 15;
	if (x == 10){
		System.out.ptinln("xは10です");
		}
	//条件式がfalseのため実行されない


	{}はブロックと呼ばれる。複数の処理をあとめたいときに、離床する。
	{}の後ろに ; は不要


#### else

if ならば、
else ifの条件以外では

	int x = 20;
	if(x <30){
		System.out.println("xは30より小さい");

	}else{
		System.out.println("xは30以上");

	}

#### else if

	int x= 25;

	if(x >= 30){
		System.out.println("xは30以上");

	}else if (x > 20){
		System.out.println("xは20より大きく、30より小さい");

	}else{
		System.out.println("xは20以下");
	}


**複数の条件をならべても、事項されるのは最初に合致した条件のみ。なので、条件の順番に注意する

	int x = 40;

	if (x>=30){
		System.out.println("xは30以上");

	}else if(x > 20){

		System.out.println("xは20より大きく30より小さい");
	}else{
		System.out.println("xは20以下");

	}

#### switch分

条件の値が**case**と一致するときに、処理が実行される
caseのあとの**コロン**を忘れないようにする
//セミコロンではない


	switch(条件の値){
		case 値1:
			処理;
			break;

		case 値2:
			処理;
			break;

		case 値3:
			処理;
			break;
	}

#### ifとswitch


	**if文**
	int x = 8;
	if(x % 2 == 0){
		System.out.println("偶数です");
	}else if ( x % 2 == 1){
		System.out.println("奇数です");
	}

	**switch文++
	int x = 8;
	switch(x % 2){
		case 0:
			System.out.println("偶数です");
			break;
		case 1:
			System.out.println("奇数です"):
			break;
	}


#### break

switchを終了する命令。breakがないと、合致した処理をおこなったあとの処理も実行してしまう

	int x = 8;
	switch(x % 2){
		case 0:
			System.out.println("偶数です"):
			// breakなし
		case 1:
			System.out.println("奇数です");
			break:
			//こちらも実行される
	}

#### default

どのcaseとも一致しなかった場合に実行する処理をdefaultに指定することができる
if文のelseに似ている

	swich(rank){
		case 1:
			Sstem.out.println("金"):
			break:
		case 2:
			Sstem.out.println("銀"):
			break:
		case 3:
			Sstem.out.println("銅"):
			break:
		default:
			System.out.println("メダルを獲得できませんでした"):
			break;

	}

インデントを使いみやすくする


### 繰り返し処理

	while(条件){
		繰り返す処理;
	}


繰り返し処理の流れ
1.変数の初期化
2.条件
3.繰り返す処理
4.変数の更新（2.に戻る）

	int i=1; // 1

	while(i<=5){ //2
		System.out.println(i); //3
		i++; //4
	}

	int 8 = 1:
	while(i <=5){
		System.out.println(i + "回ジャンプしました");
		i++;
	}


無限ループ
	int i = 1;
	while ( i <= 5){

		System.out.println(i + "回ジャンプしました");
		// i に 1を足し忘れているので、"1"の出力が無限に続く

	}

#### for文
forの後の()内に**変数の初期化; 条件式; 変数の更新**の3つを記述する
それおぞれはセミコロンでくるギルが、最後の変数の更新には、セミコロンはつけない

	for (int i = 1; i<=5; i++){
		System.out.println(i);
	}



#### break
繰り返し処理を終了させるためには、条件をfalseにする以外に、breakを使って強制的に終了させる方法がある。
if文なお↓の条件分岐と組み合わせることで任意の箇所で売り返しを終了させることができる

	for (int i = 1; i<=10; i++){
		if(i>5){
			break;
		}
		Sytem.out.println(i);
	}


#### continue
その回（周）の処理だけをスキップして、次の周処理を実行する
if文と組み合わせて利用するのが一般的

	for (int i = 1; i<=10; i++){
		if (i % 3 == 0){
			continue;
		}
		System.out.pritnln(i);
	}


## 配列
変数のセットのようなもの
複数の値をまとめていれておける。
配列は仕切りのある鉾をイメージする
それぞれのスペースに値が入っている

要素
配列にはいっているそれぞれの値のこと


配列を扱う場合には、配列型の変数に配列を代入します。
配列型は、「int型の要素を持つ配列型」「String型の要素をもつ配列型」と指定刷る必要がある

int[] : 数値を要素にもつ配列
String[] : 文字列を要素に持つ配列

変数の型指定とことなり、スペースは空けない。
int[] String[] .// []の前にはスペースを空けない

### 配列の作り方
{}の中に、,コンマで区切りながら値を記入する

	int[] numbers = {4,13,20};

	string[] names = {"John", "Kate", "Bob"};

#### インデックス番号と要素の取得

インデックス番号
配列の要素は前から{0, 1, 2,...}と雛妓が割り振られているもの。

配列の各要素は、++配列名[インデックス番号]とシているすることで取得できる

	String[] names = {"John", "Kate", "Bob"};
	System.out.println("私の名前は" + names[0] + "です");

	// 出力の結果 私の名前は John です


#### 配列の上書き
徳亭の要素に値を代入すると上書きが可能

	String[] names = {"John", "Kate", "Bob"};
	names[0] = "Willliam";
	System.out.prinln(names[0]);

存在しない要素に値を代入はできない。下の場合エラーがでる

	String[] names = {"John", "Kate", "Bob"};
	names[3] = "Julia";

	//エラーが発生する

### 配列と繰り返し

配列のそれぞれの要素に対して同様の処理を実行する場面がある。このときには繰り返し処理を行う
配列の要素を全て出力するたもえに、for 文をもちいる

	String[] names = {"John", "Kate", "Bob"};

	for (int i = 1; i<3; i++){
		Sytemm.out.println("Hello" + names[i]);
	}

#### lengthメソッド

破裂には要素の数を数えるlengthメソッド
++配列.length**のように、ドット. でえつなぐ

	String[] names = {"John", "Kate", "Bob"};
	for ( int I = 0; i < names.length: i++){
		System.out.println("Hello " + names[i]);

	}

#### 閣僚for文

	for (データ型 変数名 : 配列名) {
		繰り返す処理;
	}

配列の各要素の値を順に代入する変数を用意する
繰り返しのたびに、変数nameeに配列namesの要素が順に代入される
拡張for文では、自動的に要素の数だけ繰り返しが行われる

	String[] names = {"John", "Kate", "Bob"};

	for (String name: names){
		System.out.println(name);
	}


	**通常のfor文**
	String[] names = {"John", "kate", "Bob"};
	for ( int i = 0; i < names.length; i++{
		System.out.println(names[i]);
	}

	++拡張for文**
	String[] names = {"John", "kate", "Bob"};
	for (String name: names){
		System.out.prinln(name);
	}


## メソッドとクラス

### メソッド
何らかの処理を割り当てた部分。
これまでmainメソッドだけに記述してきた処理部分んを、メソッドに切り分けていく
javaのファイルを実行すると、自動的に**mainメソッド**が実行される
mainメソッドの処理をメソッドに切り分けるとmainメソッドが買うメソッドに指示をだし、各メソッドがここの処理を実行するという構造になる

### メソッドを使ったプログラム

	**メソッドに切り分けられていないコード**
	class Main{
		public static void amain(String args[]){
			System.out.println("私の名前はKate Jonesです");
			System.out.println("年齢は27歳です");
			double height = 1.6;
			double weight = 400;
			System.out.println("身長は1.6mです");
			System.out.println("体重は50kgです");
			double bmi = weight / height / height;
			System.out.println("BMI" + bmi +  "です");

			boolean isHealthy =  bmi >= 18.5 && bmi < 25.0;
	}

	**メソッドに切り分けられたコード++
	class Main{
		public static void main(String[] args){
			printData(fullNmae("Kate", "jones"), 27, 1.6, 50.0));

		}
		public static void printData(String name int age, double height, double weight){

		}
		public static double bmi(double height, double weight){
			return weight / height / height;
		}
		publilc static String fullName(String firstname, String lastName){

		}
	}

#### メソッドを呼び出す
メソッドは処理をまとめた部品
下の例では、helloメソッドを定義し、mainメソッドでhelloメソッドを呼び出している

1. mainメソッドが呼ばれる
2. mainメソッドの中で、helloメソッドが呼ばれる
3. helloメソッドの中で、System.out.println("Hello World")が実行される

	class Main{
		public static void main(String[] args){ // 1.
			hello(); // 2.
		}
		public static void hello(){
			System.out.println("Hello World"); // 3.
		}
	}

### メソッドの定義
public static voidはとりあえず定型として覚えておく
ブロック（{}で囲まれた部分）の中にそのメソッドが行う処理を記述する
メソッドの名前は、処理の内容が想像できるものにする

	public static void メソッド名() {
		実行する処理
	}

	public static void hello(){
		System.out.println("Hello World");
	}

#### メソッド定義の場所

メソッドは**クラスの中**に定義する

	class Main { //Main クラスのブロック
		public static void main(String[] args){

		}
		public static void hello(){
			System.out.println("Hello World");

		}
	} //Mainクラスのブロック


#### メソッドの呼び出し
**メソッド名()**とするだけ。()を忘れないようにする

	class Main{
		public static void main(String[] args){
			hello():
			hello(): //メソッド名()
		}
		public static void hello(){
			System.out.println("Hello World");
		}
	}

### 引数
メソッドに与える追加情報
メソッドを呼び出すときに、一緒に引数を渡すと、メソッドのなかでその値を利用できる

#### 引数を受け取るメソッド
メソッドに引数を渡すには、まず、**引数を受け取れるメソッドを定義しないといけない**
そのためには、メソッドの定義部分で、引数を受け取るための箱となる変数（**仮引数**）を指定する
public sttatic void メソッド名() の()に仮引数を指定する
仮引数は「、変数定義と導尿に、データ型を指定する必要がある

	public static void メソッド名(データ型 変数名){
		実行する処理;
	}

	public static void hello(String name){

	}


#### メソッドに引数を渡す
**メソッド名(引数)**としてメソッドを呼び出す
渡された日位数は、メソッドの仮引数で指定した変数にぢに有され、その変数はメソッドの処理の中で用いいることができる

	class Main{
		public static void main(String[] args){
			hello("Bob");
		}
		publiic static void hello(String name){
			System.out.println(name + "さんこんにちは");
	}


#### 複数の引数をもつメソッド

引数は複数渡せる。複数の引数を受け取るためには、仮引数をコンマ,で区切って定義する
異なるデータ引数を複数受け取ることもできる、引数を受け取る順番も任意にきめることができる
引数は、左から「第一引数」「第二引数」「...」となっている

	public static void メソッド名(データ型 変数名, データ型 変数名){

	}

	public static void printPrice(Stirng item, int price){
		Systemmm.out.print(item + "は" + price + "円です");
	}

	class Main{
		public static void main(String[] args){
			printPrice("ピザ", 3000);
			printPrice("コーラ"、150);
		}
		public static void printPrice(String item, int price){
			System.out.println(item + "は" + prince + "円です");
		}
	}

#### 引数を渡す順番
仮引数は任意に順番を決められるが、メソッドを呼び出すときには、仮引数の順番通りに引数を渡す
下の場合、エラーとなる。String型の仮引数に整数をいれようとするので

	class Main{
		public static void main(String[] args){
			printPrice(2000, "ピザ");
		}
		public static void printPrice(String item, int price(
			System.out.println(item + "は" + prince + "円です");
		}
	}

###  戻り値
メソッドの処理結果を、メソッドの呼び出し元でつかいたい場合、メソッドが戻り値を返すようにする

#### 戻り値のあるメソッド

++return++を使うとreturnの値をメソッドの呼び出し元に返すことができる
戻り値があるメソッドは、戻り値のデータ型を指定する。定数であった**public static void**で指定する
下の例では、addメソッドの戻り値は整数なので、　puclic static int となる

	public static 戻り値のデータ型 メソッド名(引数){
		return 戻り値;
	}

	public static int add(int a, int b){
		retunr a + b; // 呼び出し元に値を返す

	}

戻り値がある場合、メソッドの呼び出し部分がそのまま値に変わる。メソッドの呼び出し部分を変数に代入できる

	public static void main(String[] args){
		int total = add(7,5);

		System.out.println(total);
	}
	public static int add(int a, int b){
		return a + b;
	}


### void
voidは**戻り値がない**という意味
戻り値がない（returnがない）メソッドには、voidを指定する

	public static void hello(){
		System.out.println("こんにちは");
	}

	// 出力するだけで値は返さない




#### オーバーロード
同名の「メソッドは原則定義できない。
ただし**引数の型**や**個数**が違う場合は、メソッドを定義できる
このように同名のメソッドを定義することをオーバーロードどいう


### メソッドからメソッドを呼ぶ
メソッドはmainメソッド以外からも呼び出し可能。

#### メソッドを組み合わせる

	public static void main(String[] args){
		System.out.println(avearage(3,8));
	}

	public satic double average(int a, int b){
		int  total = add(a, b);
		return (double)total/ 2;
	}

	public static int add(int a, int b){
		rerutn a + b;
	}

### 真偽値を返すメソッド

	public static boolean isEven(int a){
		return a % 2 == 0;
	}

	----------------------------------------

	public static void main(String[] args){
		int number = 9;
		if(isEven(number)){
			System.out.println(number + "は偶数です");
		}else{
			System.out.println(number + "は奇数です";
		}
	public static boolean isEven(int a){
		return a % 2 == 0;
	}

	//結果; aは奇数です


## クラス

クラスごとに切り分ける。今まではMainクラス内に、メソッドが多くなってしまった


### 複数のクラスをつかう

クラス
メソッドという小さな部品をまとめる、より大きな部品。
これまではmainメソッドと同じクラス（Mainクラス）のメソッドを使ってきたが、他のクラスのメソッドを利用刷ることも可能

Main クラスが、 Personクラスのメソッドを利用する

### 他のクラスのメソッドを呼びだ↓す
**クラス名.メソッド名()**とすることで、他のクラスのメソッドを呼び出せる

	[Main.java]
	class Main{
		public static void main(String[] args){
			Person.hell(); // クラス名.メソッド名

		}
	}

	----------------------------------------
	[Person.java]

	class Person{ //クラス名
		public static void hello() { // メソッド名
			System.out.println("Hello World");
		}
	}


### クラスの定義

** class クラス名 **とする
クラス名の最初の文字は**大文字**とする
ファイル名は、**クラス名.java**とする

	[クラス名.java] //ファイル名

	class クラス名{
		// ここにメソッドを定義
	}

	[Person.java] // ファイル名はクラス名
	class Person{ // 大文字から開始

	}


Personクラスをつくり、Mainクラスのmainメソッド以外をPersonクラスに移す
こうすると、mainメソッド以外の**ロジック（論理）**部分をPersonクラスにまとめる
実行部分をMainクラスに残す
実行用のクラスと、ロジックをまとめるクラスという役割分担が明確になる

	[Main.java]
	class Main{
		public static void main(String[] args){
			String name = Person.fullName("Kate", "Jones"); //PersonクラスのfullNameメソッドを呼び出す
			System.out.println(name);
		}
	}

	[Person.java]
	class Person{
		public static String fullName(String firstName, String lastName){
			return firstName + " " + lastName;
		}
	}


Javaは、ファイルではなく、**クラスを実行する**
また実行時にmainメソッドが呼ばれるが、正確にはmainメソッドをもつクラスしか実行できない
（mainメソッドのないクラスは、他クラスから呼び出して使用する）
またクラス名に関係なく、実行時には、mainメソッドが呼ばれる（Mainクラスだから、mainメソッドが呼ばれる、というわけではない）

	[Main.java]

	Mainクラス
		main メソッド

	**Mainクラスを実行すると、mainメソッドが自動で実行される**

	----------------------------------------

	[Person.java]
	Personクラス
		mainメソッドはなし

	**Personクラスを実行すると、mainメソッドがないため、エラーとなる。（※他のクラスから呼び出している）**



## 外部ライブラリ

Javaでは他人が作ったクラスを利用することもできる
このクラスを**外部ライブラリ**と呼ぶ

世界中のエンジニアがつくった便利なメソッドを利用することで、開発の幅は一気に広がる

### 外部ライブラリの読み込み
**import**をもちいる

数学的なメソッドを持つMathというクラス（ライブラリ）を読み込むには、class定義より上で、**import java.lang.Math**とする
**java.lang**おの部分んは、Mathクラスの場所を示している　// 本当はもっと正確な意味があるが、場所を示す程度と言っている

	[Main.java]
	import java.lang.Math;

	class Main{
		public static void main(String[] args){

		}
	}

Mathクラスのmaxメソッドを使ってみる。
maxメソッドは、引数に渡した2つの数値の大きい方を返してくれる
round: 引数の小数点以下を四捨五入して返す

	[Main.java]

	import java.lang.Math:
	class Main{
		public static void main(String[] args){
			int max = Math.max(3, 8);
			System.out.println("最大値は" + max + "です");
		}
	}

よく利用される外部ライブラリは自動で読み込まれる
importせずとも利用可能
**java.lang.クラス名**となる外部ライブラリは、すべて自動で読み込まれる

### コンソールへの入力とScanner

コンソールに値を「入力」し、その値をプログラム内で使うこともできる
**Scanner**というライブラリを遣えば、コンソールへの入力を受け取れる

Scannerを初期化し、scannerという変数にいれる。
Scannerでは**初期化したものを代入した変数を用いて**メソッドを呼びだす
scanner.next()とすると、コンソールに入力された。文字列を受け取ることができる
scanner.next()が呼ばれると、処理が一旦中断し、コンソールに値が入力されるのを待つ。


	[Main.java]

	import java.util.Scanner;

	class Main{
		public static void main(String[] args){
		Scanner scanner = new Scanner(System.in); // Scannerの初期化
		System.out.print("あなたの名前; ");
		String name = Scanner.next(); //文字列の入力を受け取る
		// 処理が一旦中断され、値が入力されたら、次の処理へ進む

		System.out.print("あなたの名前は" + name + "です");
		// System.out.printは、改行せずに値を出力する命令
		}
	}



### 数値の入力を受け取る
整数を受け取るメソッドは**nextInt**  
小数を受け取るメソッドは**nextDouble**

## オブジェクト指向

オブジェクト指向はプログラミングの考え方
オブジェクト指向はプログラミングとして、「もの」を中心に考える
プログラムのなかに「もの」に似たオブジェクトを作りだし、そのオブジェクトを中心にプログラムを組み立てる

### クラスとインスタンス
クラスはインスタンスの設計図
インスタンスはオブジェクトの別名
インスタンス（オブジェクト）は、クラスをもとに作成される

インスタンスは「情報」と「振る舞い」を持つ

クラスはメソッドをまとめる部品と説明されたが、（前章3では）
しかし、最大の特徴は、インスタンスの**設計図**になること

インスタンスは**実体**という意味

	class クラス名{

	}


クラスからインスタンスを生成するには**new クラス名()**とする


	Main.java

	class Main{
		public static void main(String[] args){
			new Person(); //Person クラスのインスタンスを生成
		}
	}

	Person.java
	class Person{

	}


### インスタンスは変数に代入して使用する
変数にインスタンスを代入するには**クラス型 変数名 = new クラス名();**とする

変数名の前には、**クラス型を指定する。クラス名がそのままクラス型になる**


インスタンスを複数生成する

	class Main{
		public static void main(String[] args){
			Person person1 = new Person();
			Person person2 = new Person();
			Person person3 = new Person();
		}
	}


- インスタンスフィールド
	- インスタンスの情報に当たるもの
- インスタンスメソッド
	- インスタンスの振る舞いにあたるもの

### インスタンスメソッドの定義

	class Person {
		public void hello(){
			System.out.println("こんにちは");
		}
	}


インスタンスメソッドは、**public 戻り値の型 メソッド名()**で定義する

### インスタンスメソッドの呼び出し
インスタンスメソッドは、インスタンス（を代入した変数）に対して呼び出す。
ドッド.を使って呼び出す



	Person person1 = new Person():
	person1.hello(); // インスタンスに対して呼び出す


### インスタンスフィールド
インスタンスフィールドは情報を格納しておく変数に過ぎない
その変数はクラスの一番上に定義する
** public データ型 変数名**というように、変数定義の前にpublic をつける

	class Person{
		public String name; //名前を入れる変数を定義する
	}

インスタンスを生成するときに、各インスタンスにフィールドがコピーされるというイメージをもっておく

### インスタンスフィールドへのアクセス
** インスタンス名.フィールド名** とドット.を用いてアクセスする。
値の**取得**と**セット（代入）**が可能

	Person person1 = new Person();
	person1.name = "Suzuki"; // name に値をセット

	System. out.println(person1.name);
	// 結果 : Suzuki



### クラスの中でインスタンスをつかう。
インスタンスフィールドnameの値をつかいhelloメソッドで、自分の名前とともに出力する
helloメソッドのなかでnameフィールドの誤を使えば良い

	class Person {
		public String name;
		public void hello(){
			//こんにちは、私はnameです。
		}
	}

#### this

メソッド内でインスタンスフィールドにアクセスするためには、**this**という特殊な変数を用いる
thisはクラそのスメソッドの定義のなかでのみ使用できる
thisはメソッドが呼ばれたときに、メソッドを読み出しているインスタンスに置き換えられる

	[Person.java]

	class Person{
		public String name;
		public void hello(){
			System.out.println("こんにちは、私は" + this.name + "です");
		}

	}

	[Main.java]
	Person person = new Person();
	person.name = "Suzuki";

	person.hello();
	// 結果；こんにちは、私はSuzukiです。


## コンストラクタ

インスタンスフィールドへのセット
インスタンスを生成してから、nameフィールドの値をセットするのは、インスタンスフィールドの数が増えると面倒
おこで、インスタンスフィールドへのセットを簡単にする方法を学習する


**コンストラクタ**  
newをつかってインスタンスを生成したあとに、**自動で呼び出される**特別なメソッド

### コンストラクタの定義
特別なメソッドのために、定義方法が決まっている  
1. コンストラクタは名はクラス名と同じにする
2. 戻り値を書いてはいけない（voidも書かない）


	class クラス名{
		クラス名(){
			//インスタンスの生成じに行いたい処理
		}
	}


	[Person.java]
	class Person{
		public String name;
		Person(){
			System.out.println("インスタンスが生成されました");
			// インスタンスが生成された直後に実行される
		}
	}


	[Main.java]
	Person person = new Person();

	// 実行結果：インスタンスが生成されました


#### フィールドに値をセットする
コンストラクタを用いて、インスタンスフィールドへの値のセットを簡単にする
newでインスタンスを生成した後に、自動で自校される今　　　　- トラクタの中で、各フィールドに値をセットできるようにする

newでインスタンスをつくるさいに、**new クラス名()**の**()**には引数を渡すことができる
その引数は
直後に呼び出されるコンストラクタに受け渡される

	[Person.java]
	class Person{
		public String name;
		Person (String name){
			this.name = name;
		}
	}

	[Main.java]
	Person person = new Person("Suzuki");
	System.out.print(person.name);
	//実行結果 Suzuki


### Javaプログラム

インスタンスフィールドの定義
- どういう情報をもたせるかを定義する
- 必要最小限の情報をもたせるようにする


インスタンス生成時にインスタンスフィールドの値を設定できるように
コンストラクタを作成する

[Person.java]
 	class Person {
 		public String firstName;
 		public String lastName;

 		Person (String firstName, String LastName, ){
 			this.FirstName = firstName;
 			this.lastName = lastName;
 		}
 	}

インスタンスメソッドを定義する  


#### 他のインスタンスメソッドを呼び出す

pringData  
自分の情報をコンソールに出力する
インスタンスを指すthisを使えば、他の新スタンスメソッドを呼び出すことも可能

	[古いコード]
	public static void printDate(... ,double height, double weight){
		double bmi = bmi(height,weight);
	}

	public static double bmi(double height, double weight){
		return weight / heigh / heigh;
	}

	[新しいコード]
	pulic void printData()`
		double bmi = this.bmi();
	}

	public double bmi(){
		rerutn thi.weight / this. height / this.height;
	}


()いるのはメソッド

### クラスフィールド
インスタンスに属するインスタンスフィールド以外に、クラスに属するクラスフィールドも存在する

クラスフィールドは staticをつけて**pulic static データ型 変数名**と提議する

	class Person{
		public static データ型 変数名;
	}

例えば、何人分のインスタンスを生成したかをかぞえるために、countというフィールドで、インスタンスの生成回数をほぞんできるようにする  
count は、個々のインスタンスがもとものではなく、Personoクラスがもおっていればよいので、クラスフィールドに定義する
またフィールドには初期値を設定できる

	class Person{
		public static int count = 0 ; // クラスフィールド
		public String firstName;
		public String lastName;
	}

クラスフィールドには** クラス名.クラスフィールド名**でアクセスできる

	[Main.java]
	class Main{
		public static void main(String[] args){
			System.out.println("合計" + Person.count + "人です"):
			Person person = new Person(...);
			System.out.println("合計" + Person.count + "人です");
  		}

	}
	// 合計0人です
  	// 合計1人です

  	[Person.java]
  	class Person {
  		public static int count = 0;

  		Person(Strin		g firstName, ...){
  			Person.count++:
  		}
  	}


### コンストラクタのオーバーロード
- オーバーロード
	- 引数の型や数が違えば、同名のメソッドを定義できるシキム。
	- middleNammeを引数にうけとらいないものと、受取るもの、2つのコンストラクタを定義すれば、Javaは渡された引数に合わせて適切なコンストラクタを自動で呼び出す

```
[Person.java]
class Person{
	public String middleName;
	// 引数5個
	Person(string firstName, String lastName,...)
}

	// 引数6個
	Person(string firstName, String middlename, String lastName,...){

	}

[Main.java]
class Main {
	public static void main(String[] args){
		Person person1 = new.Person("Kate", "Jones",...); //引数5個
		Person person2 = new.Person("John", "Chiristopher", "Smith", ...); // 引数6個
	}
}
```
### 他のコンストラクタを呼び出す this()
- ただし上記のコードは、引数の違いはあるものの、ほとんど中身が重複している。
- 重複は、修正に時間がかかるので、避ける
- **this()** とすると、コンストラクタから他のコンストラクタを呼び出すことができる。
- this() はコンストラクタを呼び出すための特別なメソッド。() に引数もわたせる
- またコンストラクタの **先頭** でしか使えない

```
Person(String firstName, String midlleName,...){
	this(firstName,lastName, ...);
	this.middlename = middlename;
}
```

### fullnameメソッドの書き換え 値がない場合の初期値
- fullnameメソッドでは、firstname, middlenameは変数として持つが、middlenameをすべてのユーザーが持つとは限らない。
- なので、middlenameをfullnameを生成するのに単純に連結はできない
- middleNameには初期値として **null** がはいっている

Javaの値がない場合の初期値
| データ型 | 既定値 |
| -------- | ------ |
| String   | null   |
| int      | 0      |
| double   | 0.0    |
| boolean  | false  |

- 上記の初期値の値を参照し、場合分けをして、fullNameを記述する

```
[Person.java]
class Person{
	public String fullName(){
		if(this.middleName == null){
			return this.firstName + "" + this.lastName;
		} else {
			return this.firstName + "" + this.middleName "" + this.lastName;
		}
	}
}
```

## カプセル化 オブジェクト指向の重要な機能
- 使い手に必要のない機能を隠すこと
- クラスを作る際には、他の人に使ってほしくない機能は隠すこと
- 具体的には **フィールドとメソッドへのアクセスを制限すること**
- 以下の2つを用いて定義する
	- クラスの外部からアクセス出来るようにするには、**public**
	- アクセスできないようにするには、**private**

```
[Person.java]
class Person{
	public String name;
	private int age;
	Person(String name, int age){
		this.name = name;
		this.age = age;
	}
}
[Main.java]
class Main{
	public static void main(String[] args){
		Person person = new Person("Suzuki", 24);
		System.out.println(person.name); //"Suzuki"
		System.out.println(person.age); //エラー発生
	}
}
```
### ゲッター クラス外から安全にフィールドの値を取得すること
- privateにすると、フィールドに暮らす外からはアクセスできないが、privateでもクラス内からはアクセスが可能

```
[Person.java]
class Person{
	private String middleName;

	public String fullName(){
		if (this.middleName == null){ //クラス内からはアクセスできる

		}
	}
}
[Main.java]
class Main{
	public static void main(String[]args){
		Person person = new Person ("John", "Christopher", "Smith", ...);
		System.out.println(person.middleName) //クラス外からはアクセスできない
	}
}
```

- **ゲッター**
	- フィールドをprivateにしたうえで、クラス外から安全にフィールドの値を取得するために、フィールドの値を返すだけのメソッドを定義すること
	- 「getフィールド名」とするのが一般的

```
[Person.java]
class Person{
	pivate String middleName;

	public String getMiddleName(){ // クラス外からアクセス可能（publicを使用しているから）
		return this.middleName; // フィールドの値を返す
	}
}

[Main.java]
class Main{
	public static void main(String[]args){
		Person person = new Person("John", "Chirstopher", "Smith",...);
		System.out.prinln(person.getMiddleName()); //ゲッターを使えばアクセス可能に
	}
}
```

### セッター フィールドの値の変更
- フィールドのアクセス権をprivateにすると、フィールドのアクセスの値をクラスの外から変更することも不可能
- フィールドの値を変更するメソッドを定義する **セッター**
- 「setフィールド名」のように命名するのが一般的
```
[Person.java]
class Person{
	private String middleName;

	public void setMiddleName(String middleName){
		this.middlename = middleName; // フィールドに値をセット
	}
}
// アクセスできる場合
[Main.java]
class Main{
	public static void main(String[] args){
		Person person = new Person("Kate", "Jones", ...);
		person.setMiddleName("Claire");
		System.out.prinln(person.getMiddlename()); // Claire
	}
}
//アクセスできない場合
[Main.java]
class Main{
	public static void main(String[] args){
		Person person = new Person("Kate", "Jones",...);
		person.middleName= "Claire"; //privateなのでアクセスできない
	}
}
```

### カプセル化の定石
- フィールドは private
- メソッドは public

# 継承
- 作成したクラスの内容を他のクラスが引き継げるようにする
- 重複部分をなくすことがオブジェクト指向の原則
- 既存のクラスのフィールドやメソッドを別のクラスに引き継ぐ機能を **継承**
- 継承されるクラスを **スーパークラス**
- 継承してできる新しいクラスを **サブクラス**

## 継承の方法 extends
- **class サブクラス名 extends スーパークラス名**

```
[スーパークラス]
class スーパークラス名{

}

[サブクラス名]
class サブクラス名 extends スーパークラス名{

}
```

### スーパークラスのメソッドの呼び出し
- サブクラスはスーパークラスのフィールドとメソッドを引き継いているので、サブクラスインスタンスに対して、スーパークラスのインスタンスメソッドを呼び出すことが可能
### サブクラスのフィールドとメソッド
- サブクラスにはスーパークラスにはない独自のフィールドとメソッドを追加できる
- 一方で、スーパークラスがサブクラスで新たに定義されたフィールドやメソッドを呼び出すことはできない

## メソッドのカスタマイズ オーバーライド
- スーパークラスから継承しているメソッドの処理を、特定のサブクラスでカスタマイズしたい場合
- **オーバーライド**
	- スーパークラスから継承したメソッドと同名のメソッドをサブクラスに定義することで、スーパークラスのメソッドの内容を上書きできること
	- サブクラスのインスタンスに対してメソッドを呼び出すと、まずサブクラスのなかでメソッドを探す。そこにあれば、メソッドを呼び出す。結果的にメソッドの内容が上書きされたようになる
	- スーパークラスで **private** なフィールドとして定義されているものは、サブクラスから直接呼び出すことはできない。その場合には **ゲッター** を用いて取得するようにする

```
[Vehicle.java]
class Vehicle{
	private Stringname;
	public String getName(){
		return this.name;
	}
}

[Car.java]
system.out.println(this.name); //スーパークラスにおいてprivateであるので、アクセスできない

System.out.println(this.getName()); //スーパークラスにおいてpublicであるため、アクセスできる
```

### スーパークラスのメソッドを呼ぶ
- **super.メソッド名()** とする
- サブクラスのインスタンスメソッドからスーパークラスのインスタンスメソッドを呼び出すことが出来る

```
[Vehicle.java]
class Vehicle{
	public void printData(){
		System.out.println(this.name);
		System.out.println(this.color);
		System.out.println(this.distance);
	}
}

[Car.java]
class Car extends Vehicle{
	public void printData(){
		super.printData(); //スーパークラスのインスタンスメソッドを呼び出す
		System.out.println(this.fuel);
	}
}
```

### サブクラスのコンストラクタ
- サブクラスでコンストラクタを定義するときには、**コンストラクタの先頭で、スーパークラスのコンストラクタを呼び出す**
- スーパークラスでコンストラクタを呼び出すときには **super()** を使う
- スーパークラスに定義されたフィールドに、コンストラクタで値をセットできるようにする
	- スーパークラスとサブクラス両方で、コンストラクタを定義する
	- サブクラスのコンストラクタで、super()に引数を渡し、スーパークラスのコンストラクタを呼び出す
```
[Main.java]
class Vehicle{
	private String name;
	private String color;
	Vehicle(String name, String color){
		this.name = name;
		this.color = color;
	}
}

[Car.java]
class Car extends Vehicle {
	Car(String name, String color){
		super(name, color); //スーパークラスのコンストラクタにname, colorを渡す
		//スーパークラスのコンストラクタの呼び出し
		// 処理
	}
}
```

### スーパークラスへのアクセスを許可する protected
- ゲッター・セッターとは異なる方法
- privateの代わりに **protected** を用いると、クラス内とサブクラからのみ、アクセスを許可するフィールドを作成できる

```
[Vehicle.java]
class Vehicle{
	protected int distance = 0; //クラス内とサブクラス内からのみアクセスできる
}

[Car.java]
class Car extends Vehicle{
	public void run (int distance){
		this.distance += distance;
	}
}
```
- アクセス権
| アクセス権             | public | protected | private |
| ---------------------- | ------ | --------- | ------- |
| クラス内               | ○      | ○         | ○       |
| サブクラス内           | ○      | ○         | ×       |
| クラス、サブクラスの外 | ○      | ×         | ×       |

### 抽象メソッドと抽象クラス
- 処理が未定のメソッドを定義する方法
- メソッドの先頭に **abstracct** をつける
	- 抽象メソッドの中身には、処理は書かない
- 抽象メソッドはサブクラスがそのメソッドをオーバーライドしていないとエラーになる
- そのため、サブクラスがそのメソッドをオーバーライドし、処理内容を定義することを強制できる

```
[Vehicle.java]
abstract class Vehicle{
	abstract public void run(int distance); //処理内容は書かない
}

[Car.java]
class Car extends Vehicle {
	public void run(int distance){
		this.distance += distance; // オーバーライドして処理内容を確定する
	}
}
```

### 抽象クラス
- 抽象メソッドを1つでももつクラスは **抽象クラス** と呼ばれ、**クラス名の前に、abstract** をつえる必要がある
- 抽象クラスは、**インスタンスを生成できない**


## クラス型のフィールド
- インスタンスフィールドに暮らす方のて変数を定義することで、フィールドにインスタンスを持つことが可能に
- 下記のように定義した場合、Vehicleクラスのサブクラスでは、getOwnerメソッドを呼び出すと、その戻り値はownerメソッドのフィールドの値すなわち **Personクラスのインスタンス** となっている
- よって、getOwner().printData(); のように、Personクラスのインスタンスメソッドを呼び出すことが可能になる
```
[Person.java]
class Person{
	public static int count= 0;
	public String firstName;
	public String middleName;
	public String lastName;
}

[Vehicle.java]
abstract class Vehicle {
	public String name;
	public String color;
	private int distance = 0;
	private Person owner; // Personはクラス名。Person型のownerフィールドを追加

	public Person getOwner(){ //戻り値がPerson型
		return this.owner;
	}
	public void setOwner(Person owner){ //Person型の引数を受け取る
		this.owner = owner;
	}
}
```

- personクラスのインスタンスが乗り物を購入できるようにする
- 購入する乗り物は、Carクラスのインスタンス、Bicycleクラスのインスタンスどちらかにする
- buyメソッドは引数に、どちらの型のインスタンスも受け取る可能性があるから、オーバーロードする

```
[Person.java]
class Person{
	public void buy(Car car){
		car.setOwner(this); // このthis は、[Vehicle.java]の setOwner(Person owner) を指している
		// car型の引数を受け取る→carのメソッドを継承できる→carはvehicleのサブクラス→vehicleはperson型を継承しいている
	}
	public void buy(Bicycle bicycle){
		bicycle.setOwner(this); // buyメソッドを呼び出しているPersonクラスのインスタンスを指す
	}
	public void buy(Bike bike){
		setOwner(this);
	}
}
```

- しかし上記の方法では、Vehicleのサブクラスが増えた場合、毎回引数の型の違う同名のメソッドを定義しないといけない（上記のように）
- そこで、下記のように、Vehicle型のインスタンスを受取るようにすることで、Carクラスのインスタンスも、Bicycleクラスのインスタンスも受け取れるようになる

- 多態性
	- buy メソッドの引数のクラス型をVehicle型にできる理由は以下の通り
	- Carクラスは、Vehicleクラスを継承しているので、Carクラスのインスタンスは、Car型である前にVehicle型でもある。
	- この関係にあるとき、サブクラスのインスタンスを、スーパークラスのクラス型変数に代入することが出来る（この特徴を多態性）
	-
```
[Person.java]
class Person{
	public void buy(Vehicle vehicle){
		vehicle.setOwner(this);
	}
}

[Main.java]
class Main{
	public static void main(String[] args){
		Person person1 = new Person("kate", "Jones", ...);
		Car car = new Car("フェラーリ", "赤");
		person1.buy(car);

		Person person2 = new Person("John", "Lopez",...);
		Bicycle bicycle = new Bicycle("ビアンキ", "緑")l
		person2.buy(bicycle);
	}
}

[多態性の特徴]
Vehicle vehicle1 = new Car("フェラーリ", "赤");
Vehicle vehicle2 = new bicycle("ビアンキ", "緑");
// スーパークラス型の変数に代入できる

```
