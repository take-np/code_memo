2018/06/13

2018/06/14

#内容
- it研修


# 行動目標
- 一つひとつの意味を理解しつつ聞く（自分は他の人と比較して知識が多かったりするので
- 新しいヒトと話をするヒト
- 梅コースを完了させる（下記の項目）

# Ruby　V 10:12 11:30
○ Command Line
■ Command Line 基礎編 11:30-12:00
○ Ruby on Rails5 13:15-15:00

○ Ruby on Rails5Ⅰ?V
Ruby on Rails5 I 13:15-15:00

○ Ruby on Rails5 Ⅰ,Ⅱ道場コース



# 終わったときの自分の状態
- 細切れだった知識が関連している（コマンドラインなど）
- Rubyと、Python、Javaなど、各言語の得意分野が理解でき、それを使い分けができる。各言語の長所短所がわかる
- 
Ruby on Rails 3
	道場 1
Ruby on Rails 4, 5
	道場2
	


内容
-IT研修
Progateでレッスン

思ったこと
methodや関数といった用語の意味を確認する。正確に使うようにする

<>で囲まれたものは要素と言われる
見出し以外の部分は<p> </p>で囲む
間に表示する文字を挟む場合には<></>と開始タグと終了タグで囲む。
文字がない場合には、<>開始タグだけでオッケー


画像の表示には<img>要素を用います。
<img src="url">のように、src属性のurlの部分に画像のリンクを指定することで、画像が表示されます。 
<img>要素はテキストを囲むことがないため、終了タグが要りません。

<li>要素は、囲む要素によって種類が変わるという特徴を持っています。
<ul>要素で囲むと、黒点が先頭につきます。
<ol>要素で囲むと、数字が連番でつきます（ここでは扱いません）。
このように要素を要素で囲むことを入れ子と言います。
囲む方の要素を親要素、囲まれる要素を子要素と呼びます。

CSSとは、HTMLの要素に対して色、大きさ、配置などを指定し、ページをデザインするための言語です。



CSSは、HTMLとは別のファイルに記述します。
HTMLで用意した要素に対して、CSSを用いて「どこの」「何を」「どうする」かを指定することができます。 
図の例では、「h1要素の」「color（色）を」「red（赤）」にしています。
（このときの対象(要素名)をセレクタ、変更項目をプロパティと言います）

CSSを書くときも、図のようにインデント（字下げ）をします。
また、CSSのプロパティの末尾にはコロン（:）、行末には セミコロン（;） をつける必要があるので注意しましょう

文字の大きさを指定するにはfont-sizeプロパティを用います。 

font-familyプロパティを用いると、フォントの種類を指定することができます。「 font-family: フォント名; 」とすることで、要素にそのフォントを適用できます。フォント名にスペースがある場合は、ダブルクォーテーションで囲みます。


背景色を変えるにはbackground-colorプロパティを用います。 色の指定の方法はcolorプロパティと同様です。
「#dddddd」のように同じ値が続く場合は、「#ddd」と省略できます

要素の横幅、高さを変更したいときには、それぞれwidthプロパティ、heightプロパティを用います。 
width, height共にpxで指定していきます。
pxを書き忘れないように注意しましょう。	ー


要素の横幅、高さを変更したいときには、それぞれwidthプロパティ、heightプロパティを用います。 
width, height共にpxで指定していきます。
pxを書き忘れないように注意しましょう。


複数の要素に同じclassをつけた場合、それら全てに同じCSSが適用されます。

classにCSSを指定する際に、先頭のドット（.）を忘れてしまうとCSSが適用されません。
classの場合はドットが必要で、タグの場合は必要ない、ということをしっかりと覚えておきましょう。
<li class = ""> ダブルクオテーション内に暮らすめいを記述する


<head>要素にはページに関する情報、<body>要素には実際に表示したい内容を書きます。

<!DOCTYPE html>の部分はDOCTYPE宣言と呼ばれるもので、HTMLのバージョンを宣言するためのものです。
今回は最新バージョンのHTML5を使うため、<!DOCTYPE html>を使用します。


<head>要素にはWebページの設定に関する情報を書いていきます。
<head>要素内に記述した内容はWebページには表示されません。
<head>要素には必ず入れる3つの要素がありますが、それらについては次のレッスンで学びます。

<head>要素の中では、以下のように①文字コードの指定、②ページのタイトルの設定、③CSSの読み込みなどを行っていきます。
これらは定型文のようなものなので完全に覚える必要はありませんが、どのようなものがあるのかを知っておきましょう。

文字コード指定<meta charset = "UTF-8">
<title>aaa</title> プラブ座のタブに表示される
CSSを読み込むためには、<link rel="stylesheet">を利用
読み込むファイルの指定には、link rel = "sytlesheet" href="sytlesheet.css">のようにhref属性で読み込むcSSファイルを指定する

レイアウトは<div>要素によって構成していきます。
<div>要素の「div」は「division」の略で、要素をグループ化するために使用されます。
下の図の例では、「header」、「main」、「footer」というclass名を持った3つの<div>要素でレイアウトを分割しています。

ウェブページのレイアウトは<div>要素によって構成する
ヘッダ、フッター、っメインと各要素を指定していく

<div class="header"></div>

styleshieetにｈてlist-sytle:none;で指定すると、リスト先頭の黒丸を消すことができる

cssにて"float"プロパティを用いると、師弟したヨウ素を横並びにする
float:left;と師弟すると、ヨウ素が比田井→から準に横に並ぶ


余白の調整
padding: 値;
上下左右すべてのお方向にその大きさの余白が追加されます

「padding-top: 値;」などとすると、その方向のみに余白が追加されます。
他にpadding-bottom、padding-left、padding-right

指定したい値が方向ごとに異なる場合、個別で指定する方法もありますが、まとめて書くことも可能です。
値を4つ、スペース区切りで指定した場合、「上」「右」「下」「左」の順で適用されます。
値を2つ指定した場合、「上下」「左右」の順に適用されます。

「.header-list」の後にスペースを空けてliと続けると、「header-list」の中の<li>要素にのみCSSを適用することができます。
これにより、ヘッダーの<li>要素とフッターの<li>要素に別々のCSSを適用することができます。

続けて、メイン部分のレイアウトを作っていきましょう。 
main要素は、「copy-container」、「contents」、「contact-form」の3つの要素で構成されています。

文中の一部にCSSを適用させたい場合は、<span>要素で囲みます。
下の図では、<span>タグにCSSを指定することで、文字の色を一部変えています。
<span>要素の前後には改行は入りません。前後に改行が入るタグと入らないタグに関して、次のスライドで一旦整理してみましょう


前後で改行が入り、親要素の幅一杯に広がる要素をブロック要素といいます。これまで勉強してきた<div>要素や<h1>要素、<p>要素はブロック要素です。

<span>要素や<a>要素のように改行されない要素をインライン要素といいます。


<div>や<span>は区切りでしかない。だいたいそれらには<div class="----">とclassがついている
なので、divやspanでくぎってそれぞれにclassで命名して区別するイメージ

<img src="URL"> 挟み込むtextはないので、終了タグはなく終了する


<div>
開始タグと終了タグで囲まれているものの間は開業して大丈夫
</>


要素にボーダー（枠線）をつけるには、borderプロパティを用います。図のように、枠線の太さ、種類、色を指定して使用します。

枠線の太さ、種類、色を指定して使用します。

上下左右すべてに線を付けたい場合はborderとし、特定の場所にのみ付けたい場合は「border-bottom」のように、「border-方向」とします。
他にborder-top、border-left、border-rightなどがあります。

paddingはborderの内側の余白を作ります。
borderの外側に余白を作りたい場合、marginを用います。
値の指定の方法は、paddingと同じです。


これまで勉強してきたborder, padding, marginは、ボックスモデルという概念に基いています。
HTMLの全ての要素には、border（初期状態では表示されない）があり、その外側の余白はmargin, 内側の余白はpaddingです。


文字入力欄

それでは入力欄の作り方を見ていきましょう。
<input>要素は１行のテキスト入力を受け取るための要素です。
<textarea>要素は複数行のテキスト入力を受け取るための要素です
<input>要素は終了タグが不要な点に注意してください。



<div class="header">と<div class="footer">のような、ヘッダーとフッターのためのタグは非常によく使われるので、HTMLには<header>と<footer>というタグが用意されています。
<header>, <footer>を使う方が一般的なので、こちらを使いましょう。

トップ部分の背景には画像を表示します。
CSSで背景画像を指定するにはbackground-imageプロパティを用います。
background-image: url(画像のURL);のように使います。

background-imageで指定された背景画像は図のように表示範囲を埋め尽くすまで、繰り返し表示される性質があります。
background-size: cover;を指定すると、1枚の画像で表示範囲を埋め尽くすように画像の大きさが拡大縮小します。

中央に寄せるためにはmarginの左右にautoを指定します。
marginにautoを指定するときは、必ずwidthを併せて指定します。
なお、上下のmarginにautoを指定することはできません。
このようなcontainerクラスを作る意味は今は理解しなくて大丈夫です。
後に便利になるので、作っておきましょう。

opacityプロパティを使えば要素を透明にできます。
透明度は0.0(完全に透明) ~ 1.0(完全に不透明)の数値で指

letter-spacingプロパティを用いることで文字の間隔を指定することができます。

インラインヨウ素（<a>たぐなど）
はwidth heightが師弟できず、上下のマージンも指定できない
ボタンを作っていきます。ボタンは<a>タグで指定します。
しかし<a>タグはインライン要素であり、インライン要素にはwidthやheightが指定できないなど不便な点があります

インラインブロックヨウ素
居ブロック要素とインラインヨウ素の特区張を併せ持つインラインブロックヨウ素がある

<a>タグは初期状態でインラインヨウ素になっているが、displayプロパティを使うと、インラインブロックヨウ素に変更できうｒ
displayプロパティは


displayプロパティはblock（ブロック要素）, inline-block（インラインブロック要素）, inline（インライン要素）を指定することができます。

ボタンのように、「共通の部分があるが、それぞれ小さい変化をつけたいとき」にはクラスの名前を複数指定すると便利です。
下図のように、半角スペースで区切って複数のクラスを指定することができます。

カーソルが乗ったときの状態をhoverと言います。
CSSで、セレクタ:hoverとすることで、カーソルが乗ったときのCSSを指定することができます。

￥
text-alignプロパティを用いることで、テキスト等のインライン要素やインラインブロック要素の配置を指定することができます。
leftで左寄せ、centerで中央揃え、rightで右寄せに設定することができます。

要素を中央寄せにする方法として、margin: 0 autoとtext-align: centerを学びましたが、それらの違いを整理しましょう。
containerクラスのように、広い範囲を囲うようなブロック要素の場合はmarginを、テキストやボタンのようなインライン要素・インラインブロック要素の場合はtext-alignを使うようにしましょう。

これまで要素を透明にするにはopacityを用いてきました。
しかし、opacityには要素の中身全てを透明にするという性質があります。背景色のみを透明にするには、rgbaというものを使う必要があります。
それを学んでいきましょう。

rgbaを学ぶには、まずrgbというものを理解する必要があります。
transitionを使うとアニメーションをつけることができます。
「変化の対象」や、「変化にかかる時間」などを指定できます。
「変化の対象」にはcolorなどのプロパティを指定しますが、allを指定すると全てのプロパティに適用出来ます。
transitionは多くの場合hoverと組み合わせて使います。rgbは色の指定の仕方の1つで、3つの値の組み合わせで表示する色を決めます。色を指定するときは今まで使用してきた#ffffffのような記法を使ってもrgbを使っても構いません。


line-heightプロパティを使うと、行の高さを指定することができます。 
値が大きいほど行間が大きくなります


line-heightプロパティを使うと、行の高さを指定することができます。 
値が大きいほど行間が大きくなります

<a>タグはインライン要素なので、中身のテキストの部分しか大きさを持ちません。その結果、<a>タグをクリックできる範囲はテキストの部分だけになってしまいます。
<a>タグをブロック要素にすると、大きさが親要素いっぱいに広がるので、全体をクリックできるようになります。

font-weightプロパティを用いると文字の太さを変更することができます。normalまたはboldを指定します。
<h1>~<h6>の要素は初期状態でfont-weight: bold;となっているので、font-weight: normal;と指定すれば文字が細くなります。


ボックスのwidthやheightをpxではなく%で指定すると、親要素に対してどのくらいの幅や高さを持つか指定することができます。

レッスン紹介部分を作っていきましょう。
通常、HTMLでは要素同士が重なって表示されることはありません。
しかし、CSSを用いることで要素同士を重ねることができます。
今回は画像アイコンと文字が重なるようにする方法を学びます。

HTMLの要素同士は通常重なって表示されることはありませんが、position: absolute;を使うと、要素同士を重ねて表示することが出来ます。
サイト全体の左上部分を基準とし、そこからの位置をtopとleftを用いて指定します。また、rightやbottomを併用することも可能です。

position: absolute;の基準位置はサイト全体の左上部分ですが、この基準位置は変更することが出来ます。
基準としたい親要素にposition: relative;と指定すると、その要素の左上部分が基準位置となります。

ボックスに影を付けるためにはbox-shadowプロパティを用います。
以下の図のように「影の位置」と「影の色」を指定します。

cursorプロパティを用いることでマウスのカーソルが要素に乗ったときのカーソルの形を変えることができます。
タグによってcursorが初期状態で設定されているものもあり、例えば<a>タグは初期状態でpointerが設定されています。


セレクタにactiveを用いることで、要素がクリックされている間だけCSSを適用することができます。 
セレクタ:activeというように指定します。

box-shadow: none;とすると、影を消すことが出来ます。
このように多くのプロパティはnoneを指定することによって消すことができます。

要素の位置を変更する方法を学びましょう。
前回position: relative;はposition: absolute;の基準位置を決めるために使っていましたが、要素の位置を変更するためにも使うことが出来ます。
position: relative;をtopやleftと併用すると、その要素を本来の位置からずらせます。



クリック時に、以下の処理をすることによって、ボタンがへこんで見えるようになります。
・box-shadowをnoneにする
・position: relative;とtopによって影の分だけ位置を下げる


CSSで個タグを指定するときは、hooter a{ }のようにへいれつすればオッケー


position: fixed;を使うと、常に要素を画面上の指定した位置に固定させておくことができます。 
位置は、top、left、right、bottomを使って指定します。


z-indexプロパティは、要素の重なりの順序を指定する際に使用します。 
z-indexは整数値で指定し、値が大きいほど上に表示されます。
z-indexプロパティは必ずpositionプロパティと併用する必要があるので、注意しましょう。



RRbuy

下図のように文字列の中で、#{変数名}とすることで、変数を代入している値に置き換えて、文字列に含めることができます。
これを「変数展開」と呼びます。

変数展開をする際は注意点があります。
実はダブルクォーテーションを使った文字列の場合しか変数展開はされません。シングルクォーテーションの場合は、変数展開が行われず、そのまま文字列として出力されてしまうので注意しましょう。

数値と文字列を足し算で連結することはできません。
しかし右の図のように変数展開を用いると、数値の入った変数も問題なく文字列に含めることが可能です。
変数を文字列に含める場合は、基本的に変数展開を使うようにしましょう。

if文を用いると「もし○○ならば●●を行う」という条件分岐が可能になります。ifの後ろに条件式を書き、それが「成り立つ」場合、処理を実行します。また、処理はifとendで囲みます。

先ほどの例で出力された「true」は真偽値と呼ばれるものです。
真偽値にはtrueとfalseという2つの値しか存在しません。
条件式は、成り立つと「true」、成り立たなければ「false」という真偽値に置き換わります。よって下図のように条件式をputsしてみると、trueやfalseが出力されています。

rubyはインデント関係ない。ただ見やすくするだけのもの。Pythonとは異なる


複数の値をまとめて管理するには、配列というものを用います。
配列は、[値1, 値2, 値3]のように作ります。配列に入っているそれぞれの値のことを要素と呼びます。
配列を使うと、複数の文字列や数値をまとめて書くことができます。



変数の場合と同様に、配列の要素の値も変数展開を用いて文字列の中に含めることができます。

繰り返し処理
繰り返し処理には、each文というものを使います。
each文を使うと、配列の要素を順番に取り出して処理を行うことができます。
each文は、図のように、「配列.each do |変数名|」と書き、「end」までの間に実行したい処理を書きます。

nammes.each do |name|
	puts name
end

each文は配列の要素の数だけ繰り返し処理を行います。
図のように、「|」で囲まれた変数に配列の要素が1つずつ入っていき、その上でeach文の中の処理が実行されていきます。
each文内の変数名（name）は好きな名前をつけられますが、配列の変数名（names）の単数形にすることが慣習上多いです。

複数の値をまとめて管理する方法としては、配列の他にもハッシュというものがあります。
配列は複数の値を並べて管理するのに対して、ハッシュはそれぞれの値にキーと呼ばれる名前をつけて管理します。
次のスライドからハッシュの書き方を学んでいきましょう。

ハッシュは以下の図のように、キーの部分を文字列ではなく、先頭にコロン「:」を付けた書き方をすることもできます。
この「:name」という書き方のことをシンボルと言います。

vハッシュのキーにシンボルを用いるときには、省略した書き方をすることができます。具体的には「:key =>」を「key:」というように省略することができます。


ハッシュの書き方
# キーが文字列の書き方
{"name" => "Suzuki"m "age" =>19}
# キーがシンボルの書き方
{:name => "Suzuki", :age =>21}
# キーがシンボルの書き方（省略形）
{name:"Suzuki", age:21}
キーがシンボル省略形の場合には、キーと":"の間にはスペースを空けない


nilとは何者やねん nul と同様のものらしい

true :[flaseと nil]以外
false: flaseとnil

ここからは、要素がハッシュになっている配列を見ていきましょう。
配列の要素には、文字列や数値だけでなく、ハッシュも使うことができるので、左の図のような配列を作ることができます。
その際、コードが横に長くなることを防ぐために、右の図のように要素ごとに改行することがよくありますので、覚えておきましょう。

先ほどのハッシュの要素の値の扱い方は、さらに省略することができます。
具体的には、配列[インデックス番号][キー]で、特定のハッシュの値を用いることができます。
見慣れない書き方で難しく感じるかもしれませんが、配列[インデックス番号]がハッシュに置き換わる、というように考えると理解しやすくなります。



def ===

end

→def と endのセットで理解



ここからは、メソッドの処理結果を呼び出し元で受け取る方法を学びます。
呼び出し元で受け取る処理結果を戻り値（もどりち）と呼び、このことを「メソッドが戻り値を返す」と言います。
下のイメージ図では、addメソッドが「3」と「7」を受け取り、処理結果の「10」を呼び出し元に返しています。この「10」にあたるのが戻り値です。

メソッドの中でreturnを使うと、呼び出し元で値を受け取れるようになります。
「return 値」と書くことで、メソッドはその値を戻り値として返します。


戻り値がある場合、メソッドの呼び出し部分がそのまま戻り値に置き換わります。 
よって、図のようにメソッドの呼び出し部分を変数に代入するように書くことで、メソッドの戻り値を受け取ることができます。

戻り値も引数と同様に、様々な値を用いることができます。
また、if文で使うような条件式をreturnすると、その条件式の結果として得られる真偽値（trueまたはfalse）を返すことができます。
真偽値を返すメソッドは、メソッド名の末尾に「?」をつける慣習があるので、覚えておきましょう。

returnについて詳しく見ていきましょう。
returnは、戻り値を返すだけでなく、メソッドの処理を終了させる性質も持っています。
よって、returnの後にあるメソッドの処理は実行されませんので注意しましょう。

メソッド内で条件式ifをもちいることもできる
その場合には if 内であってもreturnが実行されれば、ソレ以降の処理は停止する
下記の場合には、priceが100以上であれば、priceが返る。また、priceが100より小さい場合には、if内はfalseで実行されず、その↓のreturn price + 10が実行される

def ship(price)
		 if sum >= 100
		 	return price
		 end
	return price + 10
end


最後に、キーワード引数という特殊な書き方について見てみましょう。
引数の数が多くなると、呼び出し側で値がどの引数に入るのかがわかりにくくなります。
キーワード引数を用いた書き方をすることで、右の図のように呼び出し側で引数を明記することができます。

class
classは設計図
class クラス名

end

classとendはセットで始まる
情報を持たせるためには、「attr_accessor シンボル」のようにします。以下の図のようにすることで、Menuクラスのインスタンスにnameという情報を持たせることができます。
また、この「name」という情報のことをインスタンス変数と呼びますので覚えておきましょう。
シンボル :名前

1つのクラスに対して、インスタンス変数は複数用意することも可能です。
今回は以下の図のように、Menuクラスに「name」と「price」の2つのインスタンス変数を用意してみましょう。

クラス（設計図）を元に、新しくインスタンスを生成するには、「クラス名.new」とします。
また、「変数名 = クラス名.new」とすることで、生成したインスタンスを変数に代入することができます。


インスタンスに情報をもたせるには、クラスで用意したインスタンス変数に値を代入する必要があります。
具体的には「インスタンス.変数名 = 値」とすることで、そのインスタンス変数に値をセットすることができます。


クラスのなかではメソッドを定義できる

クラスの中で定義したメソッドは、インスタンスに対して使うようにして呼び出します。
具体的には、「インスタンス.メソッド名」のようにすることで、そのメソッドを呼び出すことができます。
このようにクラスの中で定義し、インスタンスに対して呼び出すメソッドのことをインスタンスメソッドとよぶ
したがって、インスタンスメソッドも、引数を受け取ったり戻り値を返すことができます。




# [puts]と[return]の違い

def sum(a,b)
  puts 10
  return 20
end

x = sum(100,200)
puts x

# どの言語でもメソッドの定義は読み込まない、一旦飛ばす。
それ以降に、メソッドが利用された場合には立ち返って、メソッドを参照する。


self

インスタンスメソッドの中では、特殊な変数「self」を用いて「self.変数名」とすることで、インスタンス変数を扱うことができるようになります。
インスタンスメソッドでは、変数「self」に、呼び出したインスタンス自身が代入されています。

ここで一度、クラスとインスタンスについておさらいしましょう。
クラスは設計図のようなもので、その設計図からつくる実際の「もの」にあたるものがインスタンスです。
インスタンスが持つ情報である「インスタンス変数」と、インスタンスに対して呼び出す「インスタンスメソッド」は、クラスの中で定義します。

まずは、インスタンスを生成した直後に処理を実行することができる、initializeメソッドというものを学びましょう。
initializeメソッドは、「クラス名.new」でインスタンスを生成した直後に自動で呼び出されます。
実際の使い方については、次のスライドで見てみましょう。

initializeメソッドは、他のインスタンスメソッドと同じように定義することができます。
以下の例では、「Menu.new」でMenuインスタンスが生成された直後に、initializeメソッドが呼び出され、その中の処理が実行されます。

initializeメソッドは通常のインスタンスメソッドと同じように、引数を渡すこともできます。 
その際、「クラス.new」に対して引数を渡すことで、initializeメソッドにその値を渡すことができます。


# Pythonの場合のselfの意味

- 下の例を見ると、"self."は、"class Example"内全体でつかえるという意味
- また、クラス内で定義するメソッドでは定義する段階で引数()内に"self"は必須
- →実行するさいにはselfは必要ない（下から1,2行目)
- クラスのメソッド内だけで有効な変数には"self"はつけない→下の例の " tot "


class Example():
 
    def __init__(self, a,b,c):
        self.num1 = a
        self.num2 = b
        self.num3 = c
 
    def print_tot(self):
        tot = self.num1+self.num2+self.num3
        print(tot)
        
myinstance = Example(1,2,3)
myinstance.print_tot()


目標物では、メニュー名の左に0から順番に番号がついていました。
番号をつけるには、番号を保存するための変数（図の例では変数index）をeach文の外で用意して、each文の処理の中で値を1だけ増やして更新するようにします。


入力を受け付けるには「gets.chomp」を使います。このコードが実行されると、コンソールが入力待機状態になります。
「変数 = gets.chomp」とすることで、エンターキーを押されるまでに入力された値を変数に代入することができます。

「gets.chomp」で入力された値を受け取ることができましたが、実はこれは文字列になるため、「3」と入力しても文字列の"3"になってしまいます。
数値の計算などに用いる場合は、これを数値に変換する必要があります。
そのためには、「gets.chomp.to_i」とすることで、入力された内容を数値に変換し、計算などにも使えるようになります。


すでにあるMenuクラスを利用して、それをもとにFoodクラスとDrinkクラスをつくることができます。
そうすることで、共通部分をまとめることができ、効率的にコードを書くことができます。

あるクラスを元にして新たなクラスをつくることを「継承」と呼びます。
「class 新しいクラス名 < 元となるクラス名」とすることで他のクラスを継承して、新しいクラスを定義することができます。
このとき、新しいクラスは「子クラス」、元となるクラスは「親クラス」と呼ばれます。

子クラスにインスタンス変数を追加するためには、これまで通り「attr_accessor」を用います。 

親クラスにあるメソッドと同じ名前のメソッドを子クラスで定義すると、メソッドを上書きすることができます。これをメソッドの「オーバーライド」と呼びます。
オーバーライドをすると、子クラスのインスタンスは、親クラスのメソッドではなく、子クラスで定義したメソッドを呼び出すようになります

オーバーライドについてもう少し見てみましょう。
図のように、子クラスのインスタンスは、子クラスで定義したメソッドを優先して呼び出すようになっています。したがって、子クラスと親クラスに同名のメソッドがある場合は、子クラスのメソッドを呼び出すので、結果的にメソッドの内容が上書きされたようになります。


メソッド内の重複

オーバーライドしたメソッドの中で「super」とすることで、親クラスの同名のメソッドを呼び出すことができます。
あくまでメソッドを呼び出しているので、親クラスのメソッドの定義に合わせて、superに対して引数を渡す必要があります。


メソッドsuper

親クラスの変すんを引用するための関数
super(name: name, price; price)のように使用する
superのあとの()の間にはスペースは要らない


日付を扱うためには、Dateクラスというものを用います。
DateクラスとはRubyがすでに用意しているクラスで、図のようにrequireを用いて読み込むことで、自分でクラスを定義しなくても使うことができます。
このようにすでに用意されているクラスは、requireの書き方が少し異なるので注意しましょう。


require "date"

puts birthday.sunday?


クラスメソッドは、「def クラス名.メソッド名」とすることで定義できます。インスタンスメソッドとの違いはメソッド名の前にクラス名を書く必要がある点です。
今回はMenuクラスに、「is_discount_day?」というクラスメソッドを定義してみましょう。


インスタンスメソッドの中でクラスメソッドを呼び出す
クラスメソッドはクラスの中でも、同じように呼び出すことができます。
今回は、Menuクラスのインスタンスメソッドである「get_total_price」メソッドの中で、クラスメソッド「is_discount_day?」を呼び出してみましょう！


インスタンスメソッド
インスタンスメソッドは、インスタンスに対して呼び出す
class Menu
	def info 
	
	end
end 

menu1 = Menu.new
menu1.info


クラスメソッドはクラスに対して呼び出す
class Menu
	def Menu.is_discount_day?
	end
end

Menu.is_discount_day?


ckassメソッドとインスタンスメソッドの違い
classだとほかのクラスで必要になったときにも呼び出せる
インスタンスだと、

インスタンスは具現化したもの
クラスはその元

クラスメソッドであれば、例えば「家電の割引」に利用するときにも呼び出せる
そのクラスメソッドだけ

インスタンスメソッドはそのインスタンス固有のメソッド



# コマンドライン

touch ファイル作成
cat ファイルの中身を確認する
mkdir Directoryを作成する
cd ディレクトリの移動、ファイルのお指定はできない
ルートディレクトリ　一番親のディレクトリ
pwd カレントディレクトリを確認する (print working directory)
ls カレントディレクトリの中身を確認する

cdコマンドでは、ディレクトリを指定せずに「cd」のみで実行すると、ホームディレクトリと呼ばれるディレクトリに移動することができます。
ホームディレクトリは、下の図のように「~」で表されます。

ホームディレクトリは、ユーザーが作業をするときに起点にするディレクトリのことを言います。ユーザーが起点とするディレクトリのため、簡単に移動できるようになっています。このレッスンのホームディレクトリはprogateディレクトリに設定されています。

mv ファイルの移動 mv ファイル名 ディレクトリ名
	mv 移動したいディレクトリ 移動先のディレクトリ (ディレクトリ以下のファイルやディレクトリも一緒に移動する）
	
ファイルメイの変更
mv 現在のファイル名 新しいファイル名
mv 現在のディレクトリ名 新しいディレクトリ名


cp コピーするファイル名　新しいファイルﾒｲ
Fileをコピーするコマンド

cp -r とするこどでディレクトリもコピーできる

cp -r コピーするディレクトリ名名 新しいディレクトリ名

rm ファイルの削除
rm 削除するファイルメイ

rm -r とするとディレクトリを削除できる


# Ruby on Rails
ウェブアプリケーション作成のためのフレームワーク
フレームワークを使うと、開発に必要な作業を減らすことができるから、多くの開発者がフレームワークを利用している

Railsで開発を始めるには、左図の「rails new アプリケーション名」という
コマンドをターミナルで実行します。
このコマンドを実行することで、入力したアプリケーション名と同名のフォルダが作成され、その中に開発に必要なフォルダやファイルが用意されます。

サーバーの立ち上げ
rails server
トップページを作成するには、「rails generate controller home top」
というコマンドをターミナルで実行します。
このコマンドを実行すると、新しいWebページが自動で作られ、
「localhost:3000/home/top」というURLにアクセスできるようになります。

# rails でページを表示するには、右の3つのファイルが必要。

-ビューview
-コントローラ（controller)
-ルーティング(routing)



ビューとは、ページの「見た目」を作るためのHTMLファイルです。
ブラウザとRailsのやりとりの中で、Railsからビューが返され、ページが表示されます。
ビューはviewsフォルダの中に置かれます。
先ほどの「rails generate controller home top」を実行すると、
viewsフォルダの中に「homeフォルダ」と「top.html.erb」という
ファイルが作成されます。「erb」は少し特殊なファイル形式ですが、
今はただのHTMLファイルだと思っておいてください。

コントローラ
ページを表示するとき、Railsの中ではコントローラを経由してビューをブラウザに返しています。ページを表示するとき、Railsの中ではコントローラを経由してビューをブラウザに返しています。

コントローラファイルの中身を見てみましょう。
「rails generate controller home top」を実行したとき、
「home_controller.rb」というコントローラのファイルが作成され、ファイルの中に「topメソッド」が追加されます。
コントローラ内のメソッドを「アクション」と呼びます。

コントローラ内のアクションは、ブラウザに返すビューをviewsフォルダの中から見つけ出す役割を担っています。具体的には、アクションは、コントローラと同じ名前のビューフォルダから、アクションと同じ名前のHTMLファイルを探してブラウザに返します

ルーティングは、送信されたURLに対して「どのコントローラの、どのアクション」で処理するかを決める「対応表」のことです。
ブラウザでURLを入力すると、ルーティングがURLを見て、適切なコントローラのアクションを呼び出します。

1.ブラウザ（表示前）URL(home/top)に対応するHTMLファイルをリクエスト
2.（ルーティング（対応表）を参照し、）コントローラ(ex. home)のアクション(ex. top)を呼び出す→次にコントローラにいき
3.コントローラがURLに対応したHTMLファイルを送信する（例ではtop.html.erb)
URL 	| コントローラ 	|アクション |
homt/top|	home		|top		|

。

ルーティングは「config/routes.rb」に定義され、右図のように
「get "URL" => "コントローラー名#アクション名"」という文法で
書かれます。
これによって、ブラウザから「localhost:3000/home/top」というURLが
送信されたときに、homeコントローラーのtopアクションで処理されるようになります。
ルーティングに記述されていないURLにはアクセスできない


ルーティングを書き換えることで、トップページのURLを変更することが
できます。右図のように書き換えると、「localhost:3000/top」というURLで
トップページにアクセスできるようになります。
URLを変更しても、"home#top" の部分が変わらない限りhomeコントローラのtopアクションに対応するビューファイル（= top.html.erb）の内容がブラウザに表示されます。


トプページ以外のページはコマンドを用いて自銅滴に作れるわけではない。
トップページを作るときに入力したコマンドには、実は「コントローラ名」と「アクション名」が含まれています。
「rails generate controller コントローラ名 アクション名」を実行することで、コントローラと、それに対応したファイルが自動で用意されます。
しかし、同じ名前のコントローラがすでにある場合は、このコマンドを使うことはできません。


新しいページを追加するには、コマンドで自動生成されていた、ルーティング、コントローラ (アクション)、ビューを自分で用意する必要がるあるのじゃ。


#見た目を整えるCSSファイルの作成

CSSファイルは「app/assets/stylesheets」フォルダに入っています。 
「rails generate controller home ...」コマンドを実行したときに、
CSSファイル(home.scss)も自動生成されます。 
「scss」はCSSを拡張したもので、CSSを効率的に書く文法も使用できますが、このレッスンではCSSの文法のみを用いていきます。

画像は、「public」フォルダに配置しておくと、「<img src="/画像名" >」や「background-image: url("/画像名");」のように、画像名を指定するだけで、簡単に画像を表示することができます。
→必ず"/"をつける



「localhost:3000」 (後ろに/○○がないURL) に対応するルーティングは、
「get "/" => "コントローラ名#アクション名"」というように、URLに"/"を
指定します。

リンクを作成するためには、<a>タグでテキストを囲み、「href=" "」の中にURLを指定する必要があったことを思い出しましょう。
hrefの中身をルーティングのURL部分と同じにすることで、簡単にリンク先を指定することができます。

hrefの中身は  " / "で開始する

データベースと表示物

埋め込むRubyコードをブラウザに表示したい場合には、以下の図のように
<% %>ではなく、<%= %>を用います。

埋め込むRubyコードをブラウザに表示したい場合には、以下の図のように
<% %>ではなく、<%= %>を用います。

投稿が増えたときのために"each分" で囲む

アクションで定義する
 Rails ではビューではなく、アクションで定義することが一般的なのじゃ。
ここからはコントローラのアクション内で変数を定義してみよう。


定義する
変数
ビューで使う変数はアクション内で定義するようにしましょう。 
以下の図のように、「def index」と「end」の間で変数を定義することで、その変数をindex.html.erb内で使用することができます。 
変数の前に付いている「@」の意味は次のスライドで説明します

通常、アクションで定義した変数をビューで使用することはできません。
しかし、変数名を「@」から始めることでこの変数は特殊な変数となり、ビューファイルでも使用することができます。
ですので、アクションで定義したビュー用の変数には「@」をつけ忘れないようにしましょう。


データベースは下の図のような表でデータを管理しています。その表のことを「テーブル」と呼びます。下の図は投稿データを扱うための「postsテーブル」で、横の行が１つ１つの投稿データになっています。
また、縦の列のことを「カラム」、1行ずつのデータのことを「レコード」と呼びます。

データベール
テーブル（データベースの龍録されている表全体のこと）
カラム（列）レコード（行）で構成されている

posteテーブルを作成刷る手順
1.step1 えーたベースに変更を指示するファイルを作成する
2.データベースに変更を反映する


マイグレーションファイルと呼ばれる、データベースに変更を指示するためのファイルを作成しましょう。右の図のようなpostsテーブルを作成するマイグレーションファイルは
「rails g model Post content:text」というコマンドで作成することができます。
g: generate でも可能
posts: モデル名 テーブルを作成する場合には、Postと単数形にする
content: カラム名
text: データ型

また、「text」は「長い文字列」を意味しており、contentカラムにどのようなデータが入るかを意味しています。


データベースに変更を反映するには「rails db:migrate」を実行すればそれでよい


Railsでは、データベースに反映されていないマイグレーションファイルが存在する状態で、どこかのページにアクセスすると以下のようなマイグレーションエラーが発生してしまいます。そのため、マイグレーションファイルを作成した場合は必ず「rails db:migrate」を実行する必要があります。

テーブルを竿うさするためのモデルとよろしくお願いします。バラル特殊なクラスを用いてデータベースは扱う
クラスはいわゆると同じ
rails g modelコマンドで postsテーブルを操作するためのPostモデルがすでに生成されている。

Railsでは、データベースに反映されていないマイグレーションファイルが存在する状態で、どこかのページにアクセスすると以下のようなマイグレーションエラーが発生してしまいます。そのため、マイグレーションファイルを作成した場合は必ず
「rails db:migrate」を実行する必要があります。

Application recored を継承したクラスを「model」という

rails g model Post  の"Post"の部分はモデル名を指定する

ここで改めて「rails g model」コマンドについて見てみましょう。
「rails g model Post ...」の「Post」の部分には、実はモデル名を指定します。
そして、このコマンドによって、以下の2つのファイルが作成されます。 
・app/modelsフォルダにモデルが定義されたファイル
・db/migrateフォルダにマイグレーションファイル

ターミナル上で「rails console」と入力し実行（Enter）することで、コンソールを起動することができます。コンソールを起動した状態で、「1+1」を実行すると、その実行結果が表示されます。
また、「quit」を実行すると、コンソールを終了することができます。

コンソールでは下の図のように、変数を定義することもできます。
定義した変数は「quit」でコンソールを終了するまで使い続けることができます。

postsテーブルにdataを追加するには
1/newメソッドでpostモデルのinstanceを作成
2.postsテーブルに保存

以上2つの手順を行う。

「rails console」を使って、Postモデル（Postクラス）からPostインスタンスを作成しましょう。インスタンスを作成するにはnewメソッドを使います。
下の図のように書くことで、contentが「Hello world」であるPostインスタンスを作成することができます。

「rails console」を使って、Postモデル（Postクラス）からPostインスタンスを作成しましょう。インスタンスを作成するにはnewメソッドを使います。
下の図のように書くことで、contentが「Hello world」であるPostインスタンスを作成することができます。

rai
トップページを作るときに入力したコマンドには、実は「コントローラ名」と「アクション名」が含まれています。
「rails generate controller コントローラ名 アクション名」を実行することで、コントローラと、それに対応したファイルが自動で用意されます。
しかし、同じ名前のコントローラがすでにある場合は、このコマンドを使うことはできません。
(ex, rails generate controller home about)

homeコントローラーではなく、投稿に関することは投稿に冠するコントローラーを作成したほうがよい
→ rails generate controller posts（コントローラー名） index(アクション名）




テーブルからdataを取り出す



post = Post.first
post.content
とすることで、Post.firstで取得したdataから投稿内容を取得することができる


テーブルからすべてのデータを取り出す方法
Post.all
テーブルにある全てのデータが配列でsy得できる
データは配列であるから、Post.all[0]として取得するデータを指定できる
Post.all[0]
Post.all[0].contentとすれば投稿内容を取得できる

コンソールを用いたデータの操作
データの作成(new, save)
データの取得(Post.all, post.oontent...)

モデルはデータベースとのやりとりをする言葉
お↓ルを

コントローラーは支持を書くのみ
Postは


共通のレイアウト

Railsでは、「views/layouts/application.html.erb」に共通のHTMLを書いておくことができます。
初期状態でも、<head>タグや<body>タグなどの共通部分はこちらに書かれています。今回は、以下の図のように、ここにヘッダーを追加し、どのページでも共通のヘッダーが表示されるようにしましょう。

「views/layouts/application.html.erb」には<%= yield %>というコードがあります。top.html.erbなどの各ビューファイルは、この<%= yield %>の部分に代入され、application.html.erbの一部としてブラウザに表示されていました。この仕組みによって、ヘッダーなどの共通のレイアウトを1つにまとめることができます。


では、最後に投稿一覧ページへのリンクを追加しよう。Rails ではlink_toというメソッドを使うと<a>タグを作成することができるぞ。 link_to メソッドは Ruby のコードなので、「<%=%>」で囲むことに注意するのじゃ。

第一引数に表示する文字を、第二引数に URLを書くことでリンクが作成されるぞ。


投稿とその詳細表示

idカラム
データベースに保存されるさいに、自動的に数字が入る。
idは1から順に入っていき、データごとにちょうふくしないようになっている

created_atカラムとupdated_atカラムには、データベースに保存された時刻が自動で入るようになっています。
updated_atはデータ更新時にも時刻が更新されます。
（「データの更新」は後のレッスンで扱っていくので、ここでは理解しなくて大丈夫です。）

投稿詳細ページにて、データベースから徳亭のidを表示する方法
find_byメソッド

特定のidの投稿を取得するためには、find_byメソッドを用います。
find_byメソッドは、ある条件に合致するデータを取得することができます。
図のように、「モデル名.find_by(カラム名: 値)」とすることで、その値を持ったデータをデータベースから取得することができます。
ex. post = Post.find_by(id: 3)

idが3の投稿を取得する。
m


投稿詳細ページを作成する

新たにページを作成するとき
必要な要素
- ルーティング
- アクション
- ビュー

投稿詳細ページのURLに標示したいという後のidを入れるようにする
idをもつ投稿データを表示するようにする	

ex. URLが/posts/1やposts/2のときにshowアクションに行くようにする
→get "posts/1" => "posts#show"

ただし上記の書き方であるとidの分だけposts#showアクションをつくらないと行けない
そのまとめて投稿するために、

ルーティングのURL部分に「:」を用いて「posts/:id」と指定することで、「/posts/1」でも「/posts/2」でもshowアクションにいくようにすることができます。
「posts/:id」と書くと「/posts/◯◯」のような全てのURLが該当します。

;id以外もあり得るかも.DBではidではなく、人の名前などある。その場合には、人の名前などもありうる。

「posts/:id」というルーティングは「posts/index」より下に書かなければいけません。
ルーティングは合致するURLを上から順に探します。そのため「posts/index」よりも上に書くと、「localhost:3000/posts/index」というURLは「posts/:id」というルーティングに合致してしまいます。

showアクションでは、URLのidと、idカラムのデータが等しい投稿データを表示する必要があうｒ。
そのためにそれぞれのURLからidの部分1 2を取得する方法がある

コントローラのアクション内では、ルーティングで設定したURLの「:id」の値を取得することができます。その値はparamsという変数にハッシュとして入っています。
params[:id]と

getsのidの値を取得する
paramsという値

def show
	@id = parmas[:id]
end

変数paramsに、、{id: 1}といハッシュが入っている
アクセウしたサイトのidを取得できる。


showアクションで変数@postを定義し、idカラムの値がparams[:id]と等しい投稿をデータベースから取得して代入します。
@postをshow.html.erbで表示することで、各URLに対応した投稿のデータが表示されるようにしましょう！


showアクションで変数@postを定義し、idカラムの値がparams[:id]と等しい投稿をデータベースから取得して代入します。

posts_controller.rb
def show
	@post = Post.find_by(id: params[:id])
end


@postをshow.html.erbで表示することで、各URLに対応した投稿のデータが表示されるようにしましょう！
<div class = "posts-show-item">
	<%= @post.content %>
		<dif class = "post-time">
			%=@post.created_at %>
		</div>
	</div>


詳細画面へのリンクを作成する。

投稿一覧ページに、各投稿の詳細ページへのリンクを作成しましょう。
各投稿の内容の部分をクリックすると詳細ページに移動できるように、link_to(post.content, "/posts/#{post.id}")とします。

新規投稿ページは、「localhost:3000/posts/new」というURLでアクセスできるようにしましょう。
そのためにルーティング、アクション、ビューを追加しましょう。
アクションは、newアクションとしましょう。

HTML & CSSのレッスンで学習した<textarea>タグや<input>タグを用いることで入力フォームを作成することができます。
送信ボタンにはtype="submit"と、value="投稿"を指定することに気をつけましょう。
<textarea></textarea>

<input type="submit" value="投稿">

フォームの投稿ボタンを押すと、Rails側に投稿データが送信されます。
今回はcreateアクションを用意して、受け取った投稿データをデータベースに保存するようにします。
createアクションのURLは「/posts/create」としましょう

createアクションのルーティングを設定しましょう。
今までルーティングを書く際に「get」と書いてきましたが、フォームの値を受け取る場合は「post」とする必要があります。（この「post」はPostモデルの「Post」とは関係ありません。）
通常は「get」、フォームの値を受け取るときは「post」というように覚えておきましょう。

form_tagメソッドを用いると、フォームに入力されたデータを送信することができます。form_tagは、「form_tag(送信先のURL) do」のように送信先のURLを指定します。
これによって、<input type="submit" ...>のボタンを押した時に、指定されたURLにデータが送信されます。

form_tagメソッド
<%= form__tag("送信先のURL") do %>
<textarea></textarea>
<input  type="submit" value="投稿">

form_tagメソッドの注意点
<%= %>で囲む
do と　end の中にフォームを作る
※該当するはいんの<div></div>の外側でも内側でも問題はない。
<div はクラスを定義するためにくっついているだけのもの。ソレ以

フォーッ無の送信先を指定ても、createアクションに対応するビューをつくる、投稿を保存する、の2つの挙動を追加する

Createアクションではビューを用意するかわりにリダイレクトを用いて渡欧お香一覧画面に転送できる


他のURLに転送（リダイレクト）するには、redirect_toメソッドを用います。
redirect_toは「redirect_to(URL)」とすることで、そのページに転送することができます。

def create
	redirect_to("/posts/index") #指定したURLに転送する
end


投稿を保存する
1.投稿がcreateアクションに送信されるようにする
2.送信された内容を受取保存する

<textarea>タグにname属性を指定すると、入力データを送信することができるようになり、name属性の値をキーとしたハッシュがRails側に送られます。
<textarea name="content"></textarea>

→{content: "Rails勉強中!"}

name属性を指定したフォームに入力されたデータは、コントローラのアクション内で受け取ることが可能になります。
フォームのデータは、変数paramsで受け取ります。paramsはname属性に設定した文字列をキーとしたハッシュになっています

def create
	params[:conten] #{content; "rails 勉強中"}というハッシュが代入されている
end



実際に保存する手順に関しては、「rails console」で学んだことを思い出しましょう。
以下の図のように、Postインスタンスを作成する際にparams[:content]を用います。そのPostインスタンスを保存することで投稿機能の完成です！

def create
	@post = Post.new(content: params[:content])
	
	@post.save
	redirect_to("/posts/index")
end

入力データを受け取るためのparamsはURLからidの値を取得するときにも使いました。
paramsは以下の2通りの使い方があるので、整理して覚えておきましょう。


①「:○○」を使ったルーティングのURLから値を取得する
②「name="○○"」が付いたフォームの入力内容を受け取る


投稿の並べ替え
orderメソッドを用いることで、投稿一覧を並び替えることができます。
order(カラム名: 並び替えの順序）のように使います。並び替えの順序には、昇順（:asc）と降順（:desc）のどちらかを指定できます。
created_atを基準に降順（:desc）に並べ替えると、新しいものから順番に表示するようにできます。

def index
	@post=Post.all.order(created_at: desc)
end


pposts = Post.all.order(created_at: :desc)
の" :desc"のコロンは、そういういもの。（そのうちRailsが深く理解できてくれば、わかるようになる。	


投稿の編集

1.編集したい投稿を取得
2.その投稿のcontentの値を上書き
3.でーたべーに保存

post.content = "新しい値"とすることで、投稿のcontentの値を上書きすることができます。


その投稿に対してdestroyメソッドを用いることで、データベースから削除することができます。

新しいページを容易　　　　- ルウには
ルーティングと、アクション、それからビューが必要


どの投稿の編集ページか判別するために、投稿編集ページのURLには編集したい投稿のidを入れるようにします。そのため、showアクションと同様にルーティングにidを含むようにします。
また、postsコントローラ内にeditアクションを作成し、対応するビューとして、edit.html.erbも作成しましょう。


URLにidを含めることでどの投稿の編集ページを表示するか特定できるようになります。

get "posts/:id/edit" => "コントローラ名#アクション名"
@post.idとすると投稿データのidを取得することができるので、 変数展開を用いてURLにidを含めるようにします。
link_to("編集", "/posts/#{@post.id}/edit")


ルートのURLはスラッシュの数で見ている。なので、 /a/b/cであれば /a/:id にはかからない。スラッシュの数が少ないから
<textarea>タグでは「<textarea>初期値</textarea>」のようにタグで囲んだ部分を初期値として設定できます。 

updateアクションはフォームの値を受け取るので、ルーティングを
getではなく、postにする必要があります。
また、特定のidの投稿を更新するので、URLにidを含むようにしましょう。
投稿を編集した後は投稿一覧ページにリダイレクトさせるので、ビューは
不要です。

フォームで入力した内容をデータベースに保存するためには、フォームのデータをupdateアクションに送信する必要があります。
新規投稿ページを作ったときと同様に、form_tagメソッドを用いて、送信先を指定しましょう。


update アクション
- フォームの保内容の保存
- 投稿一覧画面への転送

post "posts/:id/update" => "posts#update"

ページの遷移
def update
	redirect_to("/posts/index")
end

[フォームの保存]
フォームで入力した内容をデータベースに保存するためには、フォームのデータをupdateアクションに送信する必要があります。
新規投稿ページを作ったときと同様に、form_tagメソッドを用いて、送信先を指定しましょう。

<=% form_tag("/posts/#{@post,id}\update") do%>
form_tagメソッドで送信先を指定する
<textarea><%=@posts.content %></textarea>
<input type="submit" value="保存" >
<%end%>


投稿の内容を更新する手順
1.URLに含まれたidを用いてデータベースから投稿データを取得する
2.フォームから編集内容を受取、投稿データを更新する

1.投稿データの取得
updateアクションのURLにはidが含まれているので、そのidを用いてデータベースから投稿データを取得する
続いて<textarea>タグにname属性を指定し、フォームの入力内容が変数paramsに代入されてupdateアクションに送信されるようにします。
updateアクションでは、フォームから送信された値を
params[:ocntent]で受取、 @post.content = params.[:contentで投稿データの内容を更新する
<%. form_tag("/posts/#{@post.id}/update") do %>
 <textarea name="content"> </textarea>
 
<% end %>

def update
	@post = Post.find_by(id: paramas [;id])
	@post.content = params[:content](フォームの値を受け取る)
	@post.save
	
end 

投稿の削除
destroyアクションを追加
destoroyアクションの機能
1.投稿の削除
2.投稿一覧画面への転送

destroyアクションでもルーティングはgetでなくpostにする

post "posts/:id/destroy" => "posts/destroy"

def destroy
	
	
	redirect_to("/posts/index")
end


"get"  と"post"の使い分け
get:
	データベースを変更しないアクション
	
post:
	データベースを変更するアクション
	

削除用のリンクを作成
 lint_toを用いてdestroyアクションへのリンクを作る
lint_to("削除", ";posts/#{@post.id}/destroy")のようにっ書くと、get "posts/:id/destroy"のように書かれたルーティングを探してしまう。なのでpost用のlink_toの書き方を見る
kink_toの第三引数に{method: "post"}を追加することで、postとして定義されているルーティン部にマッチするようになる

データベースからの削除
find_byでdataを取り出して、destroyで削除

@post.find_by(id: params[:id])
@post.destroy


不正な投稿絵＾たを制限する機能を作る
からの投稿 140文字を超える当オックをできないようにする

バリデーション
;不正なdataがデータベースに保存されないように、エータをチェッkする仕組みのこと


バリデーションの書き方

models/post.rb

xlass Post > ApplicationRecord
	validates *検証するカラム名, {検証刷る内容}
end

Postモデルのバリデーション
class Post > ApplicationRecored
	validates :content, {presence: true}
	
end

投稿の文字数を制限する

バリデーションでは、値あｇ存在しているだけでなく、文字数もチェックできる
length {maximum; 数値}

class Post < ApplicationRecord
	validates :content, {length: {maximum: 140}}
end

バリデーションで検証　　　　- ルウ内容はじつはハッシュとなっており、図のようにコンマで区切ることで、複数して刷ることっができる

class Post > applicatoinRecored
	validates :content, {presence: true, length: {...}}
	
end

  validates :content, {presence: true, length: {maximun: 140}}

ユーザー登録において値の重複がないかのチェック
class User ApplicationRecord
	validates :email, {uniqueness: ture}
end

値が空でないかのチェックは presence: true

重複がないかのチェックはuniqueness: true

バリデーションの結果によって遷移するページが異なる使用にする。



投稿をっデータベースに保存するために使用したsaveメソッドは、保存に成功した場合はtrue
失敗した場合にはfalseを返す

投稿を保存の有無で違いをつける
saveメソッドの戻り値をif文の条件式とする

def update
	if @post.save 
		#保存できた場合
		redirect_to("/posts/index")
	else
		#保存できなかった場合
		redirect_to("/posts/#{post.id}/edit")
	end
end


投稿失敗時に直前の編集内容を消さないようにする
投稿の更新が失敗した時に、直前の投稿内容が、フォームの初期値となるようにしましょう。
編集内容が消えてしまう仕組み
1.投稿失敗時にeditアクションに転送する
def update
	redirect_to("/posts/#{@post.id}/edit")
end
2.データベースから編集前のdataを取得している
def edit
	@post = Post.find_by(..)
end
3.editアクションで取得したデータを標示している
<textarea> <%=@post.content %> </textarea>


→updateアクションのppostには直前の変数内容が入っているので、
この@postをedit.html.erbで利用できるようにすれば、直前の編集内容を表示できるようになる
editアクションを経由せず、updateアクションからedit.htmerbをよく説表示すればよい


renderメソッドを用いれば、別のアクションを経由せずに直接ビューをひょうじすることができます
render("フォルダ名\ファイルメイ")のようにredirect_toメソットを使った場合と違い、そのアクション内で定義した@変数をビューでそのままあつかうことができる
renderの引数はあくまで「ファイルパス」なので、先頭に" / "をつけない。URLではないから

def update
	@post = Post.find_by(id: params[:id])
	@post.content = params[:content]
	render("posts/edit") 
end

このときの
下でfalseの場合（入力文字が140文字を超えているなど）のとき、@post.content = params[:content]の内容は141文字以上の文字のまま。post.save
def update
    @post = Post.find_by(id: params[:id])
    @post.content = params[:content]
    if @post.save
      redirect_to("/posts/index")
    else
      
      # renderメソッドを用いて、editアクションを経由せず、posts/edit.html.erbが表示されるようにしてください
      #redirect_to("/posts/#{@post.id}/edit")
      render("/posts/edit")#postコントローラーの下のeditを実行しろ、というパス。
  							# route経由でなく、そのままパスを呼んでいる。
  							# get "posts/:id/edit" => "posts#edit"URLを経由しないから、idが拾えない→だから、editの編集前のものが呼び出されない。=入力内容@post.content = params[:content]がそのまま残る
  							# URLを通らないとしても、データベースを通らないわけではない。コントローラー上でデータベースを参照するようにしてあれば、データベースは参照される。
  							# URLを通るとは、どういういことでしょうか
  
    end
  end
  
      
エラーメッセージの取得
saveメソッドを呼び出した際にバリデーションに失敗すると、Railsでは自動的にエラーメッセージが生成されるようになっています。@post.errors.full_messagesの中に、エラー内容が配列で入ります。

rails  console
> post = Post.new(content:"")
> post.errors.full_messages >[] #保存失敗前にはからの配列が入っている
> post.save => false #保存失敗
>post.reeors.full_messages => ["Contentを入力してください"] #保存失敗後には、エラーメッセージが入っている.

<% @post.errors.full_messages.each ddo ~message~ %>

  
うまく言った場合にサクセスメッセージを表示する
フラッシュ;
	ページに１度だけ表示されるメッセージ

フラッシュが表示された後、ページを更新したり、別のページに移動したりすると、フラッシュは表示されなくなる

Railsではフラッシュを表示するために、特殊な変数flashが容易されている。アクションで変数flash[:notice]に文字列を代入すると、flash[;notice]をビューで使うことができる。
変数flashには1度だけ表示されたあと、自動で削除されるようになっている。
flashはいろいろな箇所で共通で使用するので、application.html.erbで表示する

[posts_controller.rb]
def update
	if @post.save
		flash[:notice]= "標示したい文字列"
	end
	
end

[layouts/applicatoin.html.erb]
<% if flash[:notice]%>
	<div class="flash">
		<%=flash[:notice]%> #flashメッセージが存在する場合にのみ表示する	
	</div>
<%end&>


新規投稿や削除でもメッセージを表示する
新規投稿に失敗した場合に、再び新規投稿ページを表示するようにする
def create
	if @post.save
		redirect_to("/post/index")
	else
		redirect_to("/post/create")
	end


新規投稿においても、エラメッセージと直前の内容を表示する

[post_controller.rb]

def create
	@post = Post,new(content: params[;content])
	
	render("posts/new") #new アクションを経由せずにnew.html.erbを直接表示する
end

[posts.new.html.erb]

<% @post.errors.full_messages,each do |message| %>
	<div class="form-error"<
		<%= message %> #errorメッセージの表示部分
	</div>
<%end&>

<textarea> <%= @post.content %></textarea> #直前の投稿内容を表示する

new.html.erbで変数@postを使用するようにしますが、newアクションではまだ変数@postが定義されていません。なのでnewアクション経由（localhost:3000/posts/newというURL）でアクセスしたときにエラーが出てしまいます。図のように@postにPost.newを代入しておけば、うまく動くようになります。

def new
	@post = Post.new
end


下のdestroyの場合には、if elseで削除できなかった場合のエラーを出すほうが実際には親切。
サーバーとのやりとりや、存在しないidを指定されたときなど、削除できない場合も存在するから
def destroy
    @post = Post.find_by(id: params[:id])
    if @post.destroy
      flash[:notice] = "投稿を削除しました"
    end
    # 変数flash[:notice]に、指定されたメッセージを代入してください
    redirect_to("/posts/index")
 	end
 	
end



##ユーザーを作る
- ユーザー一覧
-ユーザーの詳細
-ユーザーの新規登録
-ユーザーの情報編集

rails consoleの場合には、データベースをコントロール
railsの場合には、全体的なコントロール。
またデータベースを変更する場合には、GUIツールを使う場合のほうが多い。

モデルとテーブルの作成
rails g model User#モデル名 name(#カラム名):string(#データ型) email:string(#データ型)
後のカラムとデータ型のセットは複数並べられる

rails db:migrateデータベースに変更を反映させる

table似】データを保存する手順
newメソッドでUserモデルのinstanceを作成
saveメソッドでuserstableに保存ん
rails console
> user = User.new(name: "hogehoge", eamil:"hogehoge@iii")
> user.save

ユーザー機能の追加
ユーザーの一覧
ユーザーの詳細
ユーザーの新規登録
ユーザーの情報編集


ユーザー一覧
データベースに保存されている湯～あが全て表示されるようにする
ヘッダーにユーザー一覧ページヘのリンクを追加する
ユーザーに関するusersコントローラとユーザー一覧ページのindexアクションを作る

コマンドで使うときは、なにもない時に使う
コッ万土でやるのは、前回までと同じような形でやっているのが、講義の内容になっている
なのでコマンドを使わなくても、データベースに内容を


rails g controllerコマンドを用いて、コントローラと一覧ページのアクションを作成するときに生成されるもの
- htmlの部分viewの下のhtml
- userコントローラ
- usersのscssファイル（cssのファイル）
の2つぐらいのファイルができる。

コマンドで作るとわからなくなる。自分が何を作り出したのか


@posts.each do |post|
eachのあとにはピリオドいらない
データベースからユーザーをひろってくるのは、find_by(params[:id])

ユーザーのしに登録機能
投稿の新規作成機能と同じ
1.登録ページの作成
2.ユーザーの保存
3.作成エラーメッセージの表示

登録フォーム
複数行の入力フォーム<textarea>タグ
ユーザーをとメールアドレスは1行の入力フォームで十分1行のフォームは<input>タグｗお用いて作成
<input>あtがうは終了タグ
が不要

<p>ユーザーを</p>
<input>
<p>メールアドレス</p>
<input>
<input type="submit" value="新規登録">


コントローラとアクション名の一致させておいたほうがわかりやすい、という考え方。
viewファイルの下のusers >> index.html.erbは
アクション名だけ、表示されるURLではない
→ get "signup"(#URL名) => "users#index"(コントローラとアクション名）
URLは実際のユーザーに表示されるもの

<li>
  <%= link_to("新規登録", "/signup")%>
</li>

→このときの第二引数は、URL.
コントローラとアクション 


ユーザーの保存
フォームの送信先をuser/createおとしてユーザーを保存したあとには、ユーザーの詳細ページにリダイレクトするように
フォームに入力された値を送信するには、name属性を指定する必要がある（ex. name="contents")
name属性の値が送信されるハッシュのキーにあるため、データの内容がわかりやすくなるようなname属性をそれぞれつけるようにする

<input name = "name">
<input name= "email">

送信されるparamsの中身｛name:"hogehoge", email"hogehoge@iii"}
新規登録ボタンを押す→createアクションへ

フォームの初期値
<inputタグでは" vlue "属性が　- 対が初期値になる。vaul
value 属性のなかにrubyのコードをつ買うには<%= %>を用いてvalue-"値" の中にRubyコードwお埋め込む

edit
updateアクションを作成する

ユーザー編集ページの　　　　- 買う性
変更の保存
サクセス・メッセ＾じの表示

マイグレーションファイルのみの作成
tableに画像のカラムを追加するために、コマンドを実行する
rails g migration ファイル名
rails g migration add_image_name_to_users

格納されるフォルダは、db/migrate/20170427053118_add_image_nmae_to_users.rb
→ファイルメイの先頭に作成日時が追加される

# rails g model User image_names:stringであると、モデルとマイグレーションファイルの両方が作成される

migrationファイルを生成しただけでは不十分
テーブルに変更を加えるためには、マイグレーションファイルのなかのchangeメソッドの中に変更内容を書く必要がある
rails db:migrateコマンドは、changeメソッドの中身を実行するためのもの

これまで「rails g model」によって生成されてきたマイグレーションファイルは、changeメソッドの中身が自動生成されていました。 
なので、マイグレーションファイルの中身を特に変更すること無く、そのまま「rails db:migrate」コマンドを実行することでデータベースに変更を反映することができていました。

今回は自分でchangeメソッドの中身を書く必要があります。
カラムを追加する場合には左の図のように、
「add_column :テーブル名, :カラム名, :データ型」とします。
changeメソッドの中身を追加したら、「rails db:migrate」でデータベースに変更を反映します。


ユーザー登録時に初期画像を保存するようにする
ユーザー登録時に、image_nameカラムの値が「default_user.jpg」になるようにしましょう。
createアクション内の@userを定義しているところで、newメソッドの引数としてimage_nameを追加するようにします。

def create
	@user = User.new(
		name:params[:name],
		email:params[:email],
		image_name: "default_user.jpg"
	)
	if @user.save
	
end

上記のように登録してみる

ユーザー画像を表示するためには、今まで画像を表示してきた時と同様に、HTMLの<img>タグを用います。
画像はpublic/user_imagesフォルダに保存されているので、src属性の値は「/user_images/ファイル名」とする必要があります。
Rubyのコード部分は<%= %>で囲む必要があることに注意しましょう。

<img src="<% "/user_images/#{@user.image_name}"%>">
#/user_images/default_user.jpgのようになる
<img src ="<%"/user_images/#{@user.image\name}" %>">


ユーザーが画像を設定できるようにする
左の図のように<input>タグに「type="file"」を追加することで、右の図のように画像ファイルを選択するボタンを表示することが出来ます。
また、ここではname属性は「image」としておきましょう。


画像の送信は特殊なので、form_tagに{multipart: true}を追加する必要があります。
詳しく理解する必要はないので、「画像を送信したいときには{multipart: true}をつける必要がある」ということだけ覚えておきましょう。

＜％= form_tag("...", {multipart: true}) do %>
画像を送信したいときなどには、multipart: ture


画像の保存
updateアクション
ファイル名を保存
+ 
publi/user_images内に画像を作成

Rubyのコードでフェイルを保存刷る方法
rails console

Rubyのコードでファイルを扱うには、Firleクラスをもちいる
File writeメソッドをもちいる
File.write("ファイルの場所!, !ファイルの中身)
File.write("publi\sample.txt", "Hello World")


フォームで送信された画像を保存してみる
。updateアクションに「以下の機能を追加
- ファイル名をデータベースの保存
- publiフォルダ内に画像を作成

name やemailと同様に、@user,image_nameの値を上書きする
def update
	@user = User.find_by(id; params[:id])
	puser.name=params[:name]
	puser.email=params[:email]
	pser.image_name="#@user.id}.jep"
	
	if @user.save
		
end

##publiフォルダ内に画像を作成

画像ファイルも他のnameやemailと応用に、params[:image]とすることで受け取ることができる
params[:image]のなかには送信された画像ファイルに関する情報が入っている。

画像を保存するには、画像データをもとに、画像ファイルを作成　　　　- ルウ必要がある
Fileを作成するためには、Fileクラスをもちいる。
ただし画像データは特殊なデータであるから、File.writeではなく、File.binwriteをもちいる
変数imageに対して、readメソッドをもちいることで、画像データを保存することができる

def update
	@user.image_name= "#{@user.id}.jpg"
	image = params[:image]
	File.binwrite("public/user_images/#{@user.image_name}", image.read)
	// image.readはFileの中身＝画像データ
	
end

画像が存在するか反帝する
保存する処理は、画像データが送信ｓれた場合っだけにする
画像が送信されたときにだけ、画像をこうしんするように、if文を追加する

def update

	if params[:image] //画像が送信されているかを判定する
		@user.image_name = "#{puser.id}.jpg"
		image = params[:image]
		File.binwrite("...", image.read)
	end
	
end


## ログイン・ログアウト機能

ログイン:
	サイトを操作しているユーザーが誰であるかを判別できる状態のこと


ルーティング
アクション
ビュー
get "login" => "users#login_form"

def login_form

den

login_form.html.erbにパスワード用のフォームを追加する
input タグのtype属性をpassword とすると、入力したパスワードが伏せ字となるパスワードようのフォームになる
<p> パスワード</p>
<input type="password">

パスワードカラムの追加
rails g migration add_password_to_users
→"add_password_to_users"というファイルメイの毎グレーsyんファイルを作成
マイグレーションファイルのなかっ見は右の図のようにし、
rails db:migrateを実行しておく

def change
	add_column :users#テーブル名, :password#カラム名, :string#データ型
バリデーションをせてい
ユーザーの情報には必ずpasswordの値が存在してほしい
passwordのカラムにもバリデーションをかかえる
presence; 存在するかどうかのバリデーション

class User < ApplicationRecord
	validates ;password, {presence: true}
end


フォームの値を送信する

フォームから送信された値を受け取るために、ルーティングとアクションを追加する

ルーティングはpost
フォームの値を送信するから
route.rb
	post "login" = users#login"
	
users_controller.rb
	def login
	
	end
	
フォームの送信先を指定する
 form_tagメソッド
 ※フォームにん有力された値がRails側に送信されるように、inputタグいname属性を追加する
 
<% = form_tag("/login") do %>
	<p> メールアドレス </p>
	<input name="emali">
	
	<P>パスワード</p>
	<input type="password" name="password">
<%end%>

login アクションのルーティング
/loginで2つのルーティングがかぶっているように見えるが
get と　postは異なるルーティングとして扱われるので問題ない

（link_toメソッドではデフォルトでgetのルーティングを探し、form_tagメソッドがデフォルトでpostのルーティングを探します。）

・ 対応するアクションはusersコントローラのloginアクションとなるようにしてください。
・ post URL => コントローラ名#アクション名となるようにしてください。

ログイン
ユーザーの特定
	フォームに入力されたメールアドレスとパスワードはparams[:email]とparams[:password]で受け取れる
	usersテーブルから入力された値に一致するユーザーを取得し、変数@userに代入する
	find_byメソッドは引数をコンマで区切ることで複数の条件からデータベースを検索ｄけいる
	

def login
	@user = User.find_by(email: params[:emal], password: params[:password])
	
end


ユーザーが存在する場合と存在しない場合の対処

def login
	@user = User.find_by(^
	
	if @user
		flash[:notice] = "ログインしました"
		redirect_to ("/posts/index")
	else
		render("users/login_form")
		#ログインページを再表示
	end
end

ログインフォームに入力されたメールアドレスとパスワードに一致するユーザーが存在しない場合は、エラーメッセージを表示する

ログインフォームに入力されたメールアドレスとパスワードに一致するユーザーが存在しない場合は、エラーメッセージを表示しましょう。今回のエラーメッセージはバリデーションのエラーメッセージとは異なり、「find_byメソッドで検索したが、存在しなかった」という結果を伝えるためのものなので、図のように自作する必要があります。



<users_controller.rb>
def login

	if @user
	
	else
		@error.message = "メールアドレスまたはパスワードが間違っていあす"
		render("users/login_form")
end

<login_form.html.erb>

<%= if @error_message %>
	<div class="form_error">
		<%= @error_message %> #エラーメッセージの表示
	</div>
<% end %>

### 初期値の設定


変数@emailと@passwordを定義し、それぞれにparams[:email]とparams[:password]の値を代入し、フォームに入力した値が初期値となるようにしましょう。また、変数に代入した初期値を表示するためにフォームにvalue属性を追加しましょう。
def login
	if 
	else
		@error_message = "~~~"
		@email = params[:email]
		@password = params[:password]
		render("users/login_form")
	end


end


<%= form_tag("/login") do %>
	<p>メールアドレス</p>
	<input name = "email", value = "<%= @email %>" >
	
	<p> パスワード </p>
	<input type = "password", name = "password", value = "<%= @psswrod %>" >

<%end%>

###ログイン処理の続き

ユーザーを特定したのちいには、そのユーザーの情報を保持し続ける必要がある。


## 変数session

ページを移動してもユーザー情報をほじしつづけるために sessionという特殊な変数をもちいる
sessionに網地に有された値は、ブラウザに保存されｓる
sソレ以降のアクセスでsessionの値を、ブラウザはRailsに送信する

session[:キー名] = 値
sessionに値を導入するときには、user_idをキーとし、値を代入する
@user_idを代入することで、特定したログインユーザーおの情報が保持され続ける

def login
	@user = User.find_by(...)
	
	if @user
		session[:user_id] = @user.id
	
end

ページを移動しても保持されていることをっ確認するために、ログインしたユーザーのidをヘッダーに表示する

<application.html.erb>

<li>
	<%= session[user_id] %>
</li>

	

##ログアウト機能
変数sessionのuser_idを削除する
ログイン・ログアウトは、sessionがすべて
session[:user?id]の値を空にする

def logout
	sesson[:user_id] = nil
end

logoutアクションを実装する
ルーティングは、loginと同様に、get ではなく　postとする

get と post
- データベースを変更するときに加え、sessionの値を変更する時にもpostをもちいる
get
	-データベースを変更しない場合
post
	- データベースを変更する場合
	- sessionの値をhんこうする場合

ログアウト後は、ログインページにリダイレクトする

def logout

	session[:user_id]=nil
	flash[:notice] = "ログアウトしました"
	redirect_to("/login">
end

###ヘッダーメニューの表示内容を切り替える
ログインお状態でも、ログインページへのリンクがひょうじされるが、ログイン状態では、このリンクは不要

ログイン状態標示する項目
sesson[:user_id]
投稿一覧
新規投稿
ログアウト

ログアウト状態で標示する項目
TwwtAppとは
ログイン



##ユーザー老特に成功したら、そのままログイン状態とする

ユーザー登録時にパスワードを保存する
ユーザー登録フォームに、パスワード用のフォームを追加

<new.html.erb>
<p>パスワード</p>
<input name="password" type="password" value = "<%= @user.password %>" >


ユーザー登録時に、passwordのカラムの値がっていされるようにする
<users_controller.rb>

def create
	@user = User.new(
		name: prams[:name],
		email: params[:email],
		image_name: "defaul_user.jpg",
		password: params[:password]
		)
	if @user.save
		session[:use_id} - @user.id
		#新規登録時に、作成したゆ～～ざーがそのままログイン状態になるようにする
end


ユーザー名を標示する
ログインしちえるユーザー名の表示
session[:user_id]の値を本に、ログイン中のユーザーの情報をデータベースから取得する

find_byメソッドで、usersテーブルからidの値が、session[:use_id]と等しいユーザーを種痘kし、変数に代入する

<layouts/application.html.erb>

<% current_user = User.find_by(id: sesson[:user_id]) %>

<li>
	<%= link_to(current_user.name, "/users/#{current_user.id}") %>
</li>

ヘッダーでcurrent_userという変数を定義したが、変数の定義はアクション側でするべき
application.html.erbの仕組み

各アクションに対応したビューファイルは、applicatioin.html.erbの<%= yield %>部分に代入されて表示されている
これにより、applicaton.html.erbは全アクションから呼び出されている

application.html.erbは全てのアクションで呼び出される
そのため、application.html.erbでアクション側の変数を使おうとすると、全アクションで
pcurrent_userを定義する必要がある

各コントローラの全アクションで共通する処理がある場合には、
before_actionを使うと便利
before_actionをもちいることで、アクションが呼び出される際に必ず
before_actionが実行される。これにより、全アクションで共通する処理を
一つ箇所にまとめることができる

全てのコントローラで共通する処理はapplicationコントローラにまとめられる
ログイン中のユーザーを種痘するset_current_userメソッドを停止、before_actionに指定する
こうすると、全コントローラで全アクションで、@current_userを定義できる

before_action :set_current_user

def set_current_user
	@current_user = User.fing_by(id: sesson[:user_id])
end



##ログインしていない場合のアクセス制限

ログインしていない場合でも、URLを直接入力すると、アクセスできてしまう

そこで、、@current_userがいない場合には、ログインページにリダイレクトするようにする
この処理は、他のアクションや他のコントローラでも使いたいので、appicationコントローラとbefore_actionを用いて処理を共通化させる

<applicatoin_controller.rb>

def authenticate_user
	if @current_user == nil
		flash[:notice] ="ログインが必要です"
		redirect_to("/login")
	end
end

上記は全アクションに適用したいわけではないから、、各コントローラの各アクションに指定刷る必要あり

before_actionを特定のアクションでのみ実行する

<users_controller.rb>

before_action :autenticate_user, {only: [:edit, :update}}
#onlyを用いて適用したいアクションを指定する
onlyでアクションを指定するときには、[]を用いて配列形式に

各コントローラは、applicationコントローラを継承しているから、継承元のメソッドを使うことができる


@h変数で定義した変数は同じクラスの異なるメソッド

ログインユーザーがアクセスできないページ

新規登録ページやログインページなど
ログインして

forbid_login_userメソット

applicationコントローラ内にログインユーザwを禁止する意味の
forbid_login_userメソッドを作成する

<application_controller.rb>
def forbid_login_user
	if @current_user
		flash[:notice] = "すでにログインしています"
		redirect_to("/posts/index")
	end
end

<home_controller.rb>
before_action :forbid_login_user, {only: [top]}

<users_controller.rb>
before_action :forbid_login_user, {only: [:new, :create, :login_form, :login}


###ユーザーの編集を制限する（ビュー）
ログインしているユーザー情報のみ制限できるようにする
ログインしていれば、他のユーザーの詳細ページから編集ページにアクセスできる状態
→ユーザー詳細画面の変種リンクを自分の詳細画面のときにだけ表示されるようにする

ユーザー詳細ページで、ログインしているユーザーでｈないあ場合には、編集ページへのリンクを非表示にする

<users/show.html.erb>
<% if @user.id == @current_user.id %>
	<%= link_to("編集", "users/#{puser,id}/edit") %>
<& end &>

ユーザーの変種を制限する（アクション）
直接URLにアクセスすれば、編集ページに入れる
これを防ぐために、ビューでリンクを消すのに加えて、アクション側でも同じ条件をつける

<users_controller.rb>
before_action :ensure_correct_user, {only:[:edit, :update]}
def ecsure_correct_user
	if 
		flash[:notice] = "権限がありません"
		redirect_to("/posts/index")
	end
end

to_iメソッド
ログイン中のユーザーのidは@current_use.idに代入、編集したいユーザーのidはparams[:id]に代入されている
しかし、params[:id]絵で取得できる値は文字列であり、
数値である@current_user.idと比較してもfalseとなる
to_iメソッドで@params[:id]を数値に変換する

<users_controller.rb>
before_action :ensure_correct_user,  {only: [:edit, :update]}
def ensure_correct_user
	if @current_user.id != params[:id].to?i
		flash[:notice]="権限がありません"
		redirect_to("/posts/index")
	end
end



